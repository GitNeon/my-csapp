#### 进入保护模式

****

##### 1、全局描述符表

**段描述符：**

- 和一个段有关的信息需要8字节来描述，所以称为段描述符。
- 在内存中开辟出一段空间，集中存放段的描述符，构成了一个描述符表。
- 每个段都需要一个段描述符

**全局描述符表寄存器(GDTR)：**

图例：全局描述符表寄存器

![](.\imgs\24-全局描述符表寄存器.png)

- 处理器内部有一个48位的寄存器（即全局描述符表寄存器），用于跟踪全局描述符表。
- 高32位保存的是起始线性地址，对于32位处理器，拥有32根地址线，可访问的内存范围是`0x00000000`~`0xFFFFFFFF`，共4GB内存。
- 低16位保存的是全局描述符表的界限，也就是表的大小(总字节数)减1

**全局描述符表的大小：**

- 全局描述符表的第一个字节偏移量是0，最后1字节的偏移量是表大小减1

- 由于GDT的界限是16位的，所以该表最大为64KB(2^16=65536字节/1024)，注意GDT是按字节为单位的
- 一个描述符占8个字节，因此最多定义8192的描述符。

**表的存放位置：**

![](.\imgs\25-全局描述符表的存放位置.png)

- 全局描述符表必须在进入保护模式前定义，因为进入保护模式之后，处理器要立即按照新的内存访问模式工作。
- 由于实模式下只能访问1MB的内存，所以GDT通常都定义在1MB以下的内存范围中。可以在进入保护模式之后换个位置重新定义GDT。

##### 2、GDT的存放位置

在进入保护模式前，需要将GDT定义在内存中，并在其中安装段描述符。

图例：GDT的存放位置

<img src=".\imgs\26-GDT安装位置.png"  />

​	主引导程序占用512字节，要求存放在0x7c00开始处，那么它的内存范围就是0x7C00~0x7E00。我们将GDT放在0x7E00处，因为GDT最大范围为64KB，因此它可以扩展到0x17DFF处。

##### 3、段描述符的格式

![](.\imgs\27-段描述符格式.jpg)

- 每个描述符占8个字节，或者说64位，图中下面是低32位，上面是高32位。
- 段地址是32位的线性地址，如果未开启分页功能，那么这个地址就是真实的物理地址；反之，并非真实地址，需要左移4位。
- 段基地址可以是0~4GB内存范围内的任意地址，不过建议还是选择16字节对齐的地址。
- 段界限为20位，这实际上决定了段的大小。
  - 如果偏移量从0开始，偏移量的最大值就是段边界；
  - 如果偏移量从最大值往下递减，那么偏移量的最小值就是段边界。
- G位是粒度位，
  - G=0表示段界限以字节为单位，段的扩展范围为1KB~1MB。
  - G=1表示段界限以4KB为单位，段的扩展范围为4KB~4GB。
- S位-描述符类型，S=0表示该段是系统段，S=1表示该段是代码段或数据段
- DPL表示描述符特权级，级别为0、1、2、3，0是最高级别。特权级决定该程序能够执行哪些指令或访问哪些系统资源。
- P位表示该段是否存在内存中，PF=0表示不存在。当内存紧张时，有可能仅建立了某个段的描述符，但是该段并不在内存中。当使用时，再从硬盘调入到内存中，然后将P置为1。
- D/B位是默认操作尺寸位，设立该标志位，主要是为了兼容16位保护模式的程序。
  - D=0表示指令中的有效地址或者操作数是16位的。
  - D=1表示指令中的有效地址或者操作数是32位的。
  - 对于栈端，该位就是B位，B=0，段上部边界是0xFFFF；B=1，段的上部边界是0xFFFFFFFF。
- L位是64位代码段标志。保留此位给64位处理器使用。
- AVL是保留给软件自由使用的位。
- TYPE位表示描述符的子类型
  - 数据段解释为XEWA
    - X: exectuable是否可执行，数据段总是不可执行的，X=0
    - E指示段的扩展方向，E=0向上扩展。E=1向下扩展
    - W表示读写属性，W=0表示段不允许写入，W=1可以写入
    - A已访问位，表示段最近是否被访问，A=1段被访问。
  - 代码段解释为XCRA
    - C表示特权级依从，C=0表示不依从，特权同级的段可以相互调用。C=1表示从低特权级的程序转移到该段执行。
    - R表示代码段是否允许读出，R=0表示不能读出，强行读会引发处理器异常中断。

##### 4、保护模式下的汇编程序

这段汇编程序经过了将GDT表放在合适的内存位置、安装段描述符、切换到保护模式、屏幕上显示一段文本完整步骤。

```assembly
;设置堆栈段和栈指针
 mov ax, cs
 mov ss, ax
 mov sp, 0x7c00

 ;计算GDT所在的逻辑段地址
 mov ax, [cs: gdt_base + 0x7c00]              ;低16位
 mov dx, [cs: gdt_base + 0x7c00 + 0x02]       ;高16位
 mov bx, 16
 div bx

 mov ds, ax                                   ;令DS指向该段以进行操作
 mov bx, dx                                   ;段内起始偏移地址

 ;创建0#描述符，它是空描述符，这是处理器的要求
 mov dword [bx+0x00],0x00
 mov dword [bx+0x04],0x00

 ;创建#1描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区）
 mov dword [bx+0x08],0x8000ffff
 mov dword [bx+0x0c],0x0040920b

 ;初始化描述符表寄存器GDTR
 mov word [cs: gdt_size+0x7c00],15            ;描述符表的界限（总字节数减一）

 lgdt [cs: gdt_size+0x7c00]

 in al,0x92                                   ;南桥芯片内的端口
 or al,0000_0010B
 out 0x92,al                                  ;打开A20

 cli                                          ;保护模式下中断机制尚未建立，应
                                              ;禁止中断
 mov eax,cr0
 or eax,1
 mov cr0,eax                                  ;设置PE位

 ;以下进入保护模式... ...

 mov cx,00000000000_01_000B                   ;加载数据段选择子(0x08)
 mov ds,cx

 ;以下在屏幕上显示"Protect mode OK."
 mov byte [0x00],'P'
 mov byte [0x02],'r'
 mov byte [0x04],'o'
 mov byte [0x06],'t'
 mov byte [0x08],'e'
 mov byte [0x0a],'c'
 mov byte [0x0c],'t'
 mov byte [0x0e],' '
 mov byte [0x10],'m'
 mov byte [0x12],'o'
 mov byte [0x14],'d'
 mov byte [0x16],'e'
 mov byte [0x18],' '
 mov byte [0x1a],'O'
 mov byte [0x1c],'K'
 mov byte [0x1e],'.'

 hlt                                          ;已经禁止中断，将不会被唤醒

;-------------------------------------------------------------------------------

 gdt_size         dw 0
 gdt_base         dd 0x00007e00               ;GDT的物理地址

 times 510-($-$$) db 0
                  db 0x55,0xaa
```

**A20的历史遗留问题：**

- 在8086处理器上可以利用地址回绕地址特性（0x0000 - 0xFFFF，再加1后就又回到0x0000，进位被丢失），使得一直在1MB内存区域寻址，因为8086CPU一共只有16根地址线（使用段地址+偏移地址特性达到20位）。
- 80286处理器有24根地址线，回绕地址特性失效，为了能够兼容8086的程序，则必须给出解决方案。

方案如下：

![](.\imgs\27-A20控制策略.png)

只需要强制第21根地址线恒为“0”就可以了。这样，0x0FFFFF加1的进位被强制为“0”，结果是0x000000；再加1，是0x000001……永远和实模式一样。

端口0x92的位1用于控制A20，先从该端口读出原数据，接着，将第2位（位1）置“1”，然后再写入该端口，这样就打开了A20。

汇编代码如下：

```assembly
in al,0x92                                   ;南桥芯片内的端口
or al,0000_0010B
out 0x92,al                                  ;打开A20
```

**打开保护模式：**

CPU中存在很多控制寄存器，例如CR0、CR1、CR2...一直到CR8寄存器，其中CR0寄存器中的第0位控制着保护模式的开关，即(Protection Enable, PE)保护模式允许位。

![](F:\my-computer\my-csapp\3-x86-Assembly-1\note\imgs\28-CR0-PE.png)

```assembly
 mov eax,cr0
 or eax,1
 mov cr0,eax                                  ;设置PE位
```

##### 5、保护模式总结

- 保护下**用户程序**访问内存应当存在限制，只能允许访问属于自己的数据，转移也只能在自己的各个代码段进行，多任务、多程序情况下，保护模式非常有必要。
- 保护模式是软件与硬件相结合而实现的，CPU内部通过全局描述符表寄存器（GDTR）来定位内存中的全局描述符表（GDT）。
- 全局描述符表包含很多个段描述符，段描述符其实就是记录一个段的信息，包括一个段的起始地址(基址)，段的界限，段的特权级，段的类型(代码段还是数据段)等等信息。
- 在进入保护模式前，需要在实模式下把GDT加载到内存中并安装多个段的描述符。然后通过`lgdt`命令将描述符表的线性基地址和界限加载到GDTR中。
- 接下来通过0x92端口完成对16位工作模式的程序兼容，然后设置CR0寄存器完成保护模式的切换。
- 保护模式下访问内存的过程是：给出段选择子，当处理器在执行任何改变段选择器的指令时，就将指令中提供的索引号乘以8作为偏移地址，同GDTR提供的基址相加，以访问GDT，然后后把找到的段描述符加载到寄存器中不可见的描述符高速缓存部分（加载的部分包括段的线性基地址、段界限和段的访问属性）。此后，每当有访问内存的指令时，就不再访问GDT中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址。

