#### 加载器工作流程

****

##### 1、初始化

加载想要加载一个用户程序，必须知道两点内容：

- 找到内存中什么地方是空闲的，即从哪个物理内存地址处开始加载用户程序。
- 确定用户程序所在硬盘上的存储位置，即它的起始逻辑扇区号是多少，需要读取多少个扇区。

##### 2、可用的内存范围

![](.\imgs\14-可用的内存范围.png)

- 物理地址0x0FFFF以下，是加载器及其栈的势力范围。
- 物理地址A0000以上，是BIOS和外围设备的势力范围，有很多传统的老式设备将自己的存储器和只读存储器映射到这个空间。
- 综上，我们可用的内存空间范围为10000~9FFFF，即加载器应当把用户程序加载到这个内存空间中去。

##### 3、计算加载用户程序逻辑段地址

​	这一段汇编程序(只展示重要部分代码)所做的就是把具体的物理地址转换成“段地址：偏移地址”。这样，我们就确定了用户程序要被加载到内存中的哪个位置上。

```assembly
phy_base dd 0x10000		;用户程序被加载的物理起始地址

SECTION mbr align=16 vstart=0x7c00 
	
	;设置栈段、栈指针起始位置 SS:SP = 0x0000:0x0000
	mov ax,0
	mov ss,ax
	mov sp,ax
	
	;将物理地址转换成逻辑地址，也就是段地址：偏移地址形式
	;利用除法进行右移获得段地址
	;得到的商就是段地址保存在AX中，AX=0x1000
	;余数为偏移地址DX=0x0000
	mov ax,[cs:phy_base]
	mov dx,[cs:phy_base+0x02]		;获得32位物理地址(DX:AX)除以16
	mov bx,16
	div bx
	...
	...
mbr_end:
```

图例：取得物理地址

![](.\imgs\15-取得物理地址.png)

##### 4、通过端口访问硬盘

- 加载器的下一步要进行的是从硬盘读取用户程序，也就是说需要和硬盘打交道。
- CPU可以通过端口来和I/O设备交换数据。

图例：处理器通过输出输出控制设备集中器(ICH)来IO设备通讯

![](.\imgs\16-IO设备.png)

端口：本质是位于I/O接口上的寄存器，端口的宽度可以是8位的，也可以是16位的。

端口的分配：Intel只允许65536个端口存在，端口号从0~65535（0x0000~0xffff）

端口的读写：不能使用mov指令，取而代之的是in和out指令

硬盘分配的端口号：ICH芯片内部通常集成了两个PATA/SATA接口，分别是主硬盘接口和副硬盘接口。

- 主硬盘接口分配的端口号是0x1f0～0x1f7，
- 副硬盘接口分配的端口号是0x170～0x177。

##### 5、in和out指令

**in指令：**

in指令是从端口读数据，目标操作必须是寄存器AL(8位)或AX(16位)，源操作数是DX，用来指定端口号

```assembly
in al,dx	;dx存放的是端口号，读入1字节的数据到al寄存器中
in ax,dx	;读入2字节的数据到ax寄存器中
```

也可以直接给出要访问的端口号：

```assembly
in al,0xf0
in ax,0x30
```

需要注意的是，in指令不允许内存地址作为操作数。

**out指令：**

out指令向外围设备发送数据

```assembly
out 0x37,al		;向0x37号端口发送寄存器al中的数据(1字节)
out 0xf5,ax		;向0xf5号端口发送寄存器ax中的数据(2字节)
```

```assembly
out dx,al		;发送寄存器al中的数据，说明端口为8位
out dx,ax		;发送寄存器ax中的数据，说明端口为16位
```

##### 6、通过硬盘控制器端口读扇区数据

- 硬盘的读写单位是扇区，使得主机与硬盘的数据交换是成块的。
- CHS模式：从硬盘读写数据，向硬盘控制器分别发送磁头号、柱面号、扇区号。
- LBA模式：逻辑扇区，将扇区统一编址，从0开始。
  - LBA28：使用28bit来表示逻辑扇区号，从逻辑扇区0x0000000~0xFFFFFFF，共可以表示2^28 = 268435456个扇区，每个扇区512字节，容量128G。
  - LBA48：使用48bit表示逻辑扇区号，可以管理131072TB硬盘容量。

##### 7、一段读写硬盘的汇编程序

- 要从硬盘上读取逻辑扇区，需要设置读取的扇区数量、设置起始LBA扇区号。
- 扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。

① 设置要读取的扇区数量：

```assembly
mov dx,0x1f2
mov al,0x01		;如果写入0，则表示读取256个扇区
out dx,al		;设置读取1个扇区，写入0x1f2端口号
				;不从0x1f0端口号开始写入是因为，这个端口号用于数据读写
				;不从0x1f1端口号开始写入是因为，这个端口号用于报告硬盘错误
```

② 设置起始LBA扇区号(LBA28)

28位的扇区号太长，需要将其分成4段，分别写入端口0x1f3、0x1f4、0x1f5和0x1f6

```asm
mov dx,0x1f3
mov al,0x02		;假设起始扇区号为0x02
out dx,al		;写入LBA地址0~7位

inc dx			;端口号+1，0x1f4
mov al,0x00
out dx,al		;LBA地址8~15位

inc dx			;0x1f5
out dx,al		;LBA地址16~23位

inc dx
mov al,0xe0		;0xe0 = 1110_0000B
out dx,al		;设置LBA模式，主硬盘，LBA地址24~27位
```

其中端口0x1f6含义如下：

- 低4位用于存放逻辑扇区号的最后4位
- 第4位表示从主硬盘还是从硬盘读写数据
- 剩下3位表示CHS模式还是LBA模式

![](.\imgs\18-0x1f6端口各位含义.png)

③ 请求读硬盘，向0x1f7端口写入0x20

```assembly
mov dx,0x1f7
mov al,0x20		;读命令
out dx,al
```

④ 等待读写完成

```assembly
	mov dx,0x1f7
waits:
	in al,dx
	and al,0x88		;10001000B
	cmp al,0x08		;00001000B,走到这一步就是判断DRQ标志位是否为1
	jnz waits		;等待硬盘准备好数据且不忙
```

图例：0x1f7各位含义

![](.\imgs\19-0x1f7含义.png)

⑤ 连续取出数据

```assembly
mov cx,256		;按字读取，512字节需要读取256次
mov dx,0x1f0	;0x1f0是数据端口，一旦硬盘控制器空闲，且准备就绪，
				;就可以连续从这个端口写入或者读取数据
read_word:
	in ax,dx
	mov [bx],ax		;读取的数据存放到由段寄存器DS指定的数据段,偏移地址由寄存器BX指定
	add bx,2
	loop read_word
```

##### 8、一个完整的加载器汇编程序

​	编写一个通用的、完整的加载器程序来加载用户程序，我们需要搞清楚加载器需要做什么工作，完成什么步骤，以及处理细节问题。

下面整理了加载器处理问题的步骤：

1、确定从哪个物理内存地址开始加载用户程序

- 根据图例我们选择了一个适当位置为0x1000地址处

2、用户程序位于硬盘上的什么位置，它的起始扇区号是多少

- 在本程序中假设起始扇区号为100

3、通过I/O端口访问硬盘传输用户程序数据

- 要从硬盘上读取逻辑扇区，需要设置读取的扇区数量、设置起始LBA扇区号

4、加载用户程序

- 将用户程序全部读入到内存中，需要知道用户程序的大小并转换成扇区数

5、用户程序内部段的重定位

- 用户程序在编写的时候是分段的，因此需要确定每个段的段地址

6、将控制权转移到用户程序

- 通过`jmp far`转移指令跳转到用户程序处开始执行

图例：可用于加载用户程序的空间范围

![](..\note\imgs\20-可用于加载用户程序的空间范围.png)

通过书中代码解释以及配合源码阅读，总结出加载器汇编程序编写步骤如下：

1、初始化栈段寄存器SS、栈指针寄存器SP为0

- 根据上面图例我们知道主引导扇区程序及其的栈的范围为0x00000 ~ 0x0FFFF

2、将用户程序所在的起始物理地址转换成逻辑地址

- 利用div指令做除法，左移4位即除以16
- AX存放商即存放的是逻辑地址，DX存放余数，这里没有用到

3、调用`read_hard_disk_0`过程，从硬盘中读取一个扇区

- 用户程序存放的扇区是连续的，读取第一个扇区包含的是用户程序头部内容
- 别忘记调用过程前，需要把一些用到的参数放到寄存器里，当然我们也可以用栈保存参数

4、判断程序有多大，进而决定要继续读取多少个扇区

- 每扇区来说可以存放512字节内容，但是用户程序可能不是512字节的整数倍
- 那么我们需要通过用户程序大小 / 512 来判断余数大小，若余数为0，说明用户程序所占的扇区正好是512字节；若不为0，也就是小于512字节的情况下，需要扇区总数+1
- AX存放的是扇区数，需要循环读，直到读完

5、全部读完后，需要计算入口点代码段基址

- 这一步也就是说将入口点的物理地址处理成段基址
- 采用`shr`和`ror`指令来处理，此后善于运用这两个指令，解决问题将会变得很轻松

6、最后处理段重定位表

- 也是把物理地址转换成段基址

7、将控制权转移到用户程序

- 通过`jmp far`指令实现远转移到用户程序入口点

下面是自己根据思路整理的加载器汇编程序，与书中的例子有些不同：

```assembly
;描述：程序加载器程序清单（位于主引导扇区）
;作者：fanx
;日期：2025.02.11

user_program_start equ 100	;用户程序所在扇区起始位置，声明常数不占用汇编地址

SECTION mbr align=16 vstart=0x7c00
		;设置栈段 栈寄存器SS  栈指针SP
		mov ax,0
		mov ss,ax
		mov sp,ax

		;需要将物理地址转换为段地址:偏移地址形式
		;由于地址是双字，需要两个寄存器来保存，DX放高位，AX放低位
		;除以16分别，商为段地址(AX)，余数为偏移地址(DX)
		mov ax,[cs:user_program_memory_address]
		mov dx,[cs:user_program_memory_address + 0x02]
		mov bx,16
		div bx
		mov ds,ax
		mov es,ax		;放入这两个寄存器后续使用

		;调用read_logical_sector先读取用户程序头部内容
		;也就是先读一个扇区(512字节)，包含头部信息和部分指令数据
		;然后根据头部信息计算出还要在读多少个扇区
		;准备该过程所需要的参数，也就是设置寄存器内容
		sub di,di					;寄存器DI清零0，保证高位数值正确
		mov si,user_program_start	;传入常量
		sub bx,bx					;BX清零，偏移地址存放在BX处
		call read_logical_sector


		;计算占用的逻辑扇区数
		;占用的逻辑扇区数 = 程序总长度 / 512字节
		;此段逻辑相对于书中给出的程序进行了优化
		mov dx,[0x02]		;高16位
		mov ax,[0x00]		;低16位，DX:AX获得程序总长度
		mov bx,512			;每个扇区512字节
		div bx				;AX=商（扇区数），DX=余数（扇区数需要+1）

		;判断是否需要额外读取一个扇区
		cmp dx,0			;检查余数是否为0
		je @no_remainder	;如果为0，则不需要额外读取一个扇区
							

		;有余数需要额外读取一个扇区
		inc ax

	@no_remainder:
		dec ax			;减去已经预读的扇区

		;如果ax=0, 说明用户程序小于等于512字节(扇区数为0)，直接进入主流程
		cmp ax,0
		jz main

		;否则根据已有扇区数循环读取数据，调read_logical_sector过程，把用户程序都放到内存中
		push ds			;以下要用到ds寄存器，所以先保存到栈中
		mov cx,ax		;需要循环读取的扇区数

	@loop_read:
		mov ax,ds		;|
		add ax,0x20		;| 紧挨着上一个数据段尾构造一个新的512字节段，这样做是避免用户程序太大而导致产生段内数据覆盖
		mov ds,ax		;|
		
		sub bx,bx		;每次偏移地址从0x0000开始
		inc si			;下一个逻辑扇区
		call read_logical_sector
		loop @loop_read

		pop ds			;恢复ds寄存器地址到用户头部段

	;主入口处理流程
	main:
		mov dx,[0x08]
		mov ax,[0x06]	;用户程序入口点段地址
		call calc_segment_base
		mov [0x06],ax	;将逻辑段基址存放到原来的位置中
		
		;处理所有的段重定位表
		mov cx,[0x0a]	;表项数量
		mov bx,0x0c		;表起始地址
		
	loop_relocation:
		mov dx,[bx+0x02]	;起始地址高16位
		mov ax,[bx]			;起始地址低16位
		call calc_segment_base
		mov [bx],ax			;回填基地址
		add bx,4			;下一个重定位表项，每个表项占4字节
		loop loop_relocation
		
		jmp far [0x04]		;转移到用户入口点

	;过程：读取逻辑扇区
	;输入：DI:SI=起始逻辑扇区号（28位），DI存放高12位(高12位左侧加0扩展到16位)，SI存放低16位
	;	   DS:BX=数据放置位置，DS指定的数据段，BX指定偏移地址
	read_logical_sector:
		push ax
		push bx
		push cx
		push dx	
		
		;(1)设置要读取的扇区数量
		mov dx,0x1f2
		mov al,0x01
		out dx,al
		
		;(2)设置LBA扇区号，28位的扇区号太长，需要将其分成4段，分别写入端口0x1f3、0x1f4、0x1f5和0x1f6
		; |0x1f6	   |0x1f5       |0x1f4       |0x1f3
		; 0000_0000    0000_0000    0000_0000    0000_0000
		; 位27~24      位23~16		位15~8		 位7~0
		
		;写入LBA地址7~0
		mov dx,0x1f3
		mov ax,si
		out dx,al
		
		;写入地址15~8
		inc dx
		mov al,ah
		out dx,al
		
		;写入地址23~16
		inc dx
		mov ax,di
		out dx,al
		
		;写入地址27~24，并设置为LBA模式
		inc dx
		mov al,0xe0
		or al,ah
		out dx,al
		
		;(3)请求硬盘读取数据
		mov dx,0x1f7
		mov al,0x20
		out dx,al
		
		;(4)等待读写操作完成
		mov dx,0x1f7
	waits:
		in al,dx
		and al,0x88
		cmp al,0x08
		jnz waits
			
		mov cx,256		;总共要读取的字数
		mov dx,0x1f0	;从这个数据端口读取数据
		
	readw:
		in ax,dx
		mov [bx],ax
		add bx,2
		loop readw

		pop dx
		pop cx
		pop bx
		pop ax
	  
		ret
	
	;过程：计算段基址
	;输入：DX:AX=32位物理地址
	;输出：AX=16位逻辑段地址
	;注意：尽管DX:AX中是32位的用户程序起始物理内存地址，理论上，
	;它只有20位是有效的，低16位在寄存器AX中，高4位在寄存器DX的低4位。
	calc_segment_base:
		push ds
		
		add ax,[cs:user_program_memory_address]
		adc dx,[cs:user_program_memory_address + 0x02]		;别忘了DX,AX中的内容还要基于加载的物理地址
		shr ax,4			;AX中内容右移4位，高位补0
		ror dx,4			;循环移位，把低四位移到高4位
		and dx,0xf000		;将寄存器低12位清零
		or ax,dx			;由于AX高4位为空，DX低四位有值，所以使用or指令合并这两个寄存器内容
							;现在AX中存放的就是16位逻辑地址
		pop ds
		
		ret
		
mbr_end:

user_program_memory_address	dd 0x10000	;用户程序所在内存加载的物理地址

;前面没使用部分用0填充，最后2字节代表主引导扇区结束标志
;$代表当前汇编地址
;$$代表当前汇编节（段）的起始汇编地址
times 510-($-$$) db 0
dw 0xAA55
```

##### 9、补充：call指令

总结在8086中call指令的用法。

**相对近调用：**

- 意思是被调用的过程位于当前代码段内，后跟16位操作数或者标号，
- 用目标过程的汇编地址减去当前call指令的下一条指令的汇编地址，保留16位的结果。
- 由于指令的操作数是一个有符号数，并且是16位的，因此地址范围为-32768~32767。

```assembly
call near proc_1
;近调用使用关键字near,可省略，默认是近调用
;获得标号proc_1处的汇编地址，编译阶段，编译器用标号proc_1处的汇编地址减去本指令的下一条指令的汇编地址
```

```asm
call 0x0500
;在call指令后跟一个标号和跟一个数值没有什么不同。标号是数值的等价形式，是代表标号处的汇编地址
;它依然会用这个数值减去当前指令的下一条指令的汇编地址，来得到一个偏移量
```

**间接绝对近调用**

- 被调用的过程位于当前代码段内，偏移地址存放在寄存器中或内存单元地址中。
- 指令中的操作数不是偏移量，而是真实的偏移地址。

```assembly
call cx				;目标地址在寄存器cx中，省略了关键字“near”

;访问此处内存单元，获得存放的真实地址
call [0x3000]		
call [bx]
call [bx + si + 0x02]
```

> 近调用会修改IP寄存器，先将原有IP寄存器中的值压栈，然后用计算出的偏移地址取代IP寄存器中的内容

**远调用**

- 远调用指的是段间调用，也就是说调用另外一个代码段的过程
- 远调用既需要被调用过程所在的段地址，也需要该过程在段内的偏移地址
- 直接在call指令中给出绝对地址

```asm
call far 0x2000:0x3030	;直接给出段地址：偏移地址
```

```asm
;间接调用
;这里指令给出了内存单元地址，需要从指定内存位置找到真实的偏移地址，段地址则默认在DS寄存器中
call far [0x2000]
call far [proc_1]
call far [bx]
call far [bx + si]
```

假如在数据段内声明了标号proc_1并初始化了两个字：

```asm
proc_1 dw 0x0102, 0x2000
```

这两个字分别是某个过程的段地址和偏移地址。按处理器的要求，偏移地址在前，段地址在后。也就是说，0x0102是偏移地址；0x2000是段地址。

那么，为了调用该过程，可以在代码段内使用这条指令：

```asm
call far [proc_1]
```

​	这条指令执行时，处理器访问由段寄存器DS指向的数据段，从指令中指定的偏移地址（由标号proc_1提供）处取得两个字（分别是段地址0x2000和偏移地址0x0102）；接着，将代码段寄存器CS和指令指针寄存器IP的当前内容分别压栈；最后，用刚才取得的段地址和偏移地址分别取代CS和IP的原值。

另外：

与之对应的指令是ret和retf指令，用于近返回和远返回。
