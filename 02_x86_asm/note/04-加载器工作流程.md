#### 加载器工作流程

****

##### 1、初始化

加载想要加载一个用户程序，必须知道两点内容：

- 找到内存中什么地方是空闲的，即从哪个物理内存地址处开始加载用户程序。
- 确定用户程序所在硬盘上的存储位置，即它的起始逻辑扇区号是多少，需要读取多少个扇区。

##### 2、可用的内存范围

![](.\imgs\14-可用的内存范围.png)

- 物理地址0x0FFFF以下，是加载器及其栈的势力范围。
- 物理地址A0000以上，是BIOS和外围设备的势力范围，有很多传统的老式设备将自己的存储器和只读存储器映射到这个空间。
- 综上，我们可用的内存空间范围为10000~9FFFF，即加载器应当把用户程序加载到这个内存空间中去。

##### 3、计算加载用户程序逻辑段地址

​	这一段汇编程序(只展示重要部分代码)所做的就是把具体的物理地址转换成“段地址：偏移地址”。这样，我们就确定了用户程序要被加载到内存中的哪个位置上。

```assembly
phy_base dd 0x10000		;用户程序被加载的物理起始地址

SECTION mbr align=16 vstart=0x7c00 
	
	;设置栈段、栈指针起始位置 SS:SP = 0x0000:0x0000
	mov ax,0
	mov ss,ax
	mov sp,ax
	
	;将物理地址转换成逻辑地址，也就是段地址：偏移地址形式
	;利用除法进行右移获得段地址
	;得到的商就是段地址保存在AX中，AX=0x1000
	;余数为偏移地址DX=0x0000
	mov ax,[cs:phy_base]
	mov dx,[cx:phy_base+0x02]		;获得32位物理地址(DX:AX)除以16
	mov bx,16
	div bx
	...
	...
mbr_end:
```

图例：取得物理地址

![](.\imgs\15-取得物理地址.png)

##### 4、通过端口访问硬盘

- 加载器的下一步要进行的是从硬盘读取用户程序，也就是说需要和硬盘打交道。
- CPU可以通过端口来和I/O设备交换数据。

图例：处理器通过输出输出控制设备集中器(ICH)来IO设备通讯

![](.\imgs\16-IO设备.png)

端口：本质是位于I/O接口上的寄存器，端口的宽度可以是8位的，也可以是16位的。

端口的分配：Intel只允许65536个端口存在，端口号从0~65535（0x0000~0xffff）

端口的读写：不能使用mov指令，取而代之的是in和out指令

硬盘分配的端口号：ICH芯片内部通常集成了两个PATA/SATA接口，分别是主硬盘接口和副硬盘接口。

- 主硬盘接口分配的端口号是0x1f0～0x1f7，
- 副硬盘接口分配的端口号是0x170～0x177。

##### 5、in和out指令

**in指令：**

in指令是从端口读数据，目标操作必须是寄存器AL(8位)或AX(16位)，源操作数是DX，用来指定端口号

```assembly
in al,dx	;dx存放的是端口号，读入1字节的数据到al寄存器中
in ax,dx	;读入2字节的数据到ax寄存器中
```

也可以直接给出要访问的端口号：

```assembly
in al,0xf0
in ax,0x30
```

需要注意的是，in指令不允许内存地址作为操作数。

**out指令：**

out指令向外围设备发送数据

```assembly
out 0x37,al		;向0x37号端口发送寄存器al中的数据(1字节)
out 0xf5,ax		;向0xf5号端口发送寄存器ax中的数据(2字节)
```

```assembly
out dx,al		;发送寄存器al中的数据，说明端口为8位
out dx,ax		;发送寄存器ax中的数据，说明端口为16位
```

##### 6、通过硬盘控制器端口读扇区数据

- 硬盘的读写单位是扇区，使得主机与硬盘的数据交换是成块的。
- CHS模式：从硬盘读写数据，向硬盘控制器分别发送磁头号、柱面号、扇区号。
- LBA模式：逻辑扇区，将扇区统一编址，从0开始。
  - LBA28：使用28bit来表示逻辑扇区号，从逻辑扇区0x0000000~0xFFFFFFF，共可以表示2^28 = 268435456个扇区，每个扇区512字节，容量128G。
  - LBA48：使用48bit表示逻辑扇区号，可以管理131072TB硬盘容量。

##### 7、一段读写硬盘的汇编程序

- 要从硬盘上读取逻辑扇区，需要设置读取的扇区数量、设置起始LBA扇区号。
- 扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。

① 设置要读取的扇区数量：

```assembly
mov dx,0x1f2
mov al,0x01		;如果写入0，则表示读取256个扇区
out dx,al		;设置读取1个扇区，写入0x1f2端口号
				;不从0x1f0端口号开始写入是因为，这个端口号用于数据读写
				;不从0x1f1端口号开始写入是因为，这个端口号用于报告硬盘错误
```

② 设置起始LBA扇区号(LBA28)

28位的扇区号太长，需要将其分成4段，分别写入端口0x1f3、0x1f4、0x1f5和0x1f6

```asm
mov dx,0x1f3
mov al,0x02		;假设起始扇区号为0x02
out dx,al		;写入LBA地址0~7位

inc dx			;端口号+1，0x1f4
mov al,0x00
out dx,al		;LBA地址8~15位

inc dx			;0x1f5
out dx,al		;LBA地址16~23位

inc dx
mov al,0xe0		;0xe0 = 1110_0000B
out dx,al		;设置LBA模式，主硬盘，LBA地址24~27位
```

图例：LBA逻辑扇区号在各个端口号存放情况

![](.\imgs\17-lba地址存放情况.png)

其中端口0x1f6含义如下：

- 低4位用于存放逻辑扇区号的最后4位
- 第4位表示从主硬盘还是从硬盘读写数据
- 剩下3位表示CHS模式还是LBA模式

![](.\imgs\18-0x1f6端口各位含义.png)

③ 请求读硬盘，向0x1f7端口写入0x20

```assembly
mov dx,0x1f7
mov al,0x20		;读命令
out dx,al
```

④ 等待读写完成

```assembly
	mov dx,0x1f7
waits:
	in al,dx
	and al,0x88		;10001000B
	cmp al,0x08		;00001000B,走到这一步就是判断DRQ标志位是否为1
	jnz waits		;等待硬盘准备好数据且不忙
```

图例：0x1f7各位含义

![](.\imgs\19-0x1f7含义.png)

⑤ 连续取出数据

```assembly
mov cx,256		;按字读取，512字节需要读取256次
mov dx,0x1f0	;0x1f0是数据端口，一旦硬盘控制器空闲，且准备就绪，
				;就可以连续从这个端口写入或者读取数据
read_word:
	in ax,dx
	mov [bx],ax		;读取的数据存放到由段寄存器DS指定的数据段,偏移地址由寄存器BX指定
	add bx,2
	loop read_word
```

##### 8、一个完整的加载器汇编程序

​	编写一个通用的、完整的加载器程序来加载用户程序，我们需要搞清楚加载器需要做什么工作，完成什么步骤，以及处理细节问题。

下面整理了加载器处理问题的步骤：

1、确定从哪个物理内存地址开始加载用户程序

- 根据图例我们选择了一个适当位置为0x1000地址处

2、用户程序位于硬盘上的什么位置，它的起始扇区号是多少

- 在本程序中假设起始扇区号为100

3、通过I/O端口访问硬盘传输用户程序数据

- 要从硬盘上读取逻辑扇区，需要设置读取的扇区数量、设置起始LBA扇区号

4、加载用户程序

- 将用户程序全部读入到内存中，需要知道用户程序的大小并转换成扇区数

5、用户程序内部段的重定位

- 用户程序在编写的时候是分段的，因此需要确定每个段的段地址

6、将控制权转移到用户程序

- 通过`jmp far`转移指令跳转到用户程序处开始执行

图例：可用于加载用户程序的空间范围

![](F:\my-computer\my-csapp\3-x86-Assembly-1\note\imgs\20-可用于加载用户程序的空间范围.png)

通过书中代码解释以及配合源码阅读，总结出加载器汇编程序编写步骤如下：

1、初始化栈段寄存器SS、栈指针寄存器SP为0

- 根据上面图例我们知道主引导扇区程序及其的栈的范围为0x00000 ~ 0x0FFFF

2、将用户程序所在的起始物理地址转换成逻辑地址

- 利用div指令做除法，左移4位即除以16
- AX存放商即存放的是逻辑地址，DX存放余数，这里没有用到

3、调用`read_hard_disk_0`过程，从硬盘中读取一个扇区

- 用户程序存放的扇区是连续的，读取第一个扇区包含的是用户程序头部内容
- 别忘记调用过程前，需要把一些用到的参数放到寄存器里，当然我们也可以用栈保存参数

4、判断程序有多大，进而决定要继续读取多少个扇区

- 每扇区来说可以存放512字节内容，但是用户程序可能不是512字节的整数倍
- 那么我们需要通过用户程序大小 / 512 来判断余数大小，若余数为0，说明用户程序所占的扇区正好是512字节；若不为0，也就是小于512字节的情况下，需要扇区总数+1
- AX存放的是扇区数，需要循环读，直到读完

5、全部读完后，需要计算入口点代码段基址

- 这一步也就是说将入口点的物理地址处理成段基址
- 采用`shr`和`ror`指令来处理，此后善于运用这两个指令，解决问题将会变得很轻松

6、最后处理段重定位表

- 也是把物理地址转换成段基址

7、将控制权转移到用户程序

- 通过`jmp far`指令实现远转移到用户程序入口点

```assembly
;代码清单9-1
app_lba_start equ 100           ;声明常数（用户程序起始逻辑扇区号）
                                ;常数的声明不会占用汇编地址
                                    
SECTION mbr align=16 vstart=0x7c00                                     

         ;设置堆栈段和栈指针 
         mov ax,0      
         mov ss,ax
         mov sp,ax
      
         mov ax,[cs:phy_base]            ;计算用于加载用户程序的逻辑段地址 
         mov dx,[cs:phy_base+0x02]
         mov bx,16        
         div bx            
         mov ds,ax                       ;令DS和ES指向该段以进行操作
         mov es,ax                        
    
         ;以下读取程序的起始部分 
         xor di,di
         mov si,app_lba_start            ;程序在硬盘上的起始逻辑扇区号 
         xor bx,bx                       ;加载到DS:0x0000处 
         call read_hard_disk_0
      
         ;以下判断整个程序有多大
         mov dx,[2]                      ;曾经把dx写成了ds，花了二十分钟排错 
         mov ax,[0]
         mov bx,512                      ;512字节每扇区
         div bx
         cmp dx,0
         jnz @1                          ;未除尽，因此结果比实际扇区数少1 
         dec ax                          ;已经读了一个扇区，扇区总数减1 
   @1:
         cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 
         jz direct
         
         ;读取剩余的扇区
         push ds                         ;以下要用到并改变DS寄存器 

         mov cx,ax                       ;循环次数（剩余扇区数）
   @2:
         mov ax,ds
         add ax,0x20                     ;得到下一个以512字节为边界的段地址
         mov ds,ax  
                              
         xor bx,bx                       ;每次读时，偏移地址始终为0x0000 
         inc si                          ;下一个逻辑扇区 
         call read_hard_disk_0
         loop @2                         ;循环读，直到读完整个功能程序 

         pop ds                          ;恢复数据段基址到用户程序头部段 
      
         ;计算入口点代码段基址 
   direct:
         mov dx,[0x08]
         mov ax,[0x06]
         call calc_segment_base
         mov [0x06],ax                   ;回填修正后的入口点代码段基址 
      
         ;开始处理段重定位表
         mov cx,[0x0a]                   ;需要重定位的项目数量
         mov bx,0x0c                     ;重定位表首地址
          
 realloc:
         mov dx,[bx+0x02]                ;32位地址的高16位 
         mov ax,[bx]
         call calc_segment_base
         mov [bx],ax                     ;回填段的基址
         add bx,4                        ;下一个重定位项（每项占4个字节） 
         loop realloc 
      
         jmp far [0x04]                  ;转移到用户程序  
 
;-------------------------------------------------------------------------------
read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区
                                         ;输入：DI:SI=起始逻辑扇区号
                                         ;      DS:BX=目标缓冲区地址
         push ax
         push bx
         push cx
         push dx
      
         mov dx,0x1f2
         mov al,1
         out dx,al                       ;读取的扇区数

         inc dx                          ;0x1f3
         mov ax,si
         out dx,al                       ;LBA地址7~0

         inc dx                          ;0x1f4
         mov al,ah
         out dx,al                       ;LBA地址15~8

         inc dx                          ;0x1f5
         mov ax,di
         out dx,al                       ;LBA地址23~16

         inc dx                          ;0x1f6
         mov al,0xe0                     ;LBA28模式，主盘
         or al,ah                        ;LBA地址27~24
         out dx,al

         inc dx                          ;0x1f7
         mov al,0x20                     ;读命令
         out dx,al

  .waits:
         in al,dx
         and al,0x88
         cmp al,0x08
         jnz .waits                      ;不忙，且硬盘已准备好数据传输 

         mov cx,256                      ;总共要读取的字数
         mov dx,0x1f0
  .readw:
         in ax,dx
         mov [bx],ax
         add bx,2
         loop .readw

         pop dx
         pop cx
         pop bx
         pop ax
      
         ret

;-------------------------------------------------------------------------------
calc_segment_base:                       ;计算16位段地址
                                         ;输入：DX:AX=32位物理地址
                                         ;返回：AX=16位段基地址 
         push dx                          
         
         add ax,[cs:phy_base]
         adc dx,[cs:phy_base+0x02]
         shr ax,4
         ror dx,4
         and dx,0xf000
         or ax,dx
         
         pop dx
         
         ret

;-------------------------------------------------------------------------------
         phy_base dd 0x10000             ;用户程序被加载的物理起始地址
         
 times 510-($-$$) db 0
                  db 0x55,0xaa

```

