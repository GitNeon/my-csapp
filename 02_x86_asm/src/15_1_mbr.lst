     1                                  ;主引导扇区程序
     2                                  ;负责加载内核
     3                                  
     4                                  ;常数定义
     5                                  core_base_address equ 0x00040000   ;常数，内核加载的起始内存地址
     6                                  core_start_sector equ 0x00000001   ;常数，内核的起始逻辑扇区号
     7                                  
     8                                  ;---------- 保护模式准备 --------
     9 00000000 8CC8                    	mov ax,cs                          ;设置堆栈段和栈指针
    10 00000002 8ED0                    	mov ss,ax
    11 00000004 BC007C                  	mov sp,0x7c00
    12                                  
    13                                  	;计算GDT所在的逻辑段地址
    14 00000007 2E66A1[9E7D]            	mov eax,[cs:pgdt+0x7c00+0x02]      ;GDT的32位物理地址 
    15 0000000C 6631D2                  	xor edx,edx
    16 0000000F 66BB10000000            	mov ebx,16
    17 00000015 66F7F3                  	div ebx                            ;分解成16位逻辑地址 
    18                                  
    19 00000018 8ED8                    	mov ds,eax                         ;令DS指向该段以进行操作
    20 0000001A 6689D3                  	mov ebx,edx                        ;段内起始偏移地址 
    21                                  
    22                                  	;跳过0#号描述符的槽位 
    23                                  	;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间
    24 0000001D 6667C74308FFFF0000      	mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xFFFFF
    25 00000026 6667C7430C0092CF00      	mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 
    26                                  
    27                                  	;创建保护模式下初始代码段描述符
    28 0000002F 6667C74310FF01007C      	mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，界限0x1FF 
    29 00000038 6667C7431400984000      	mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 
    30                                  
    31                                  	;建立保护模式下的堆栈段描述符      ;基地址为0x00007C00，界限0xFFFFE 
    32 00000041 6667C74318FEFF007C      	mov dword [ebx+0x18],0x7c00fffe    ;粒度为4KB 
    33 0000004A 6667C7431C0096CF00      	mov dword [ebx+0x1c],0x00cf9600
    34                                  
    35                                  	;建立保护模式下的显示缓冲区描述符   
    36 00000053 6667C74320FF7F0080      	mov dword [ebx+0x20],0x80007fff    ;基地址为0x000B8000，界限0x07FFF 
    37 0000005C 6667C743240B924000      	mov dword [ebx+0x24],0x0040920b    ;粒度为字节
    38                                  
    39                                  	;初始化描述符表寄存器GDTR
    40 00000065 2EC706[9C7D]2700        	mov word [cs: pgdt+0x7c00],39      ;描述符表的界限   
    41                                  
    42 0000006C 2E0F0116[9C7D]          	lgdt [cs: pgdt+0x7c00]
    43                                  
    44 00000072 E492                    	in al,0x92                         ;南桥芯片内的端口 
    45 00000074 0C02                    	or al,0000_0010B
    46 00000076 E692                    	out 0x92,al                        ;打开A20
    47                                  
    48 00000078 FA                      	cli                                ;中断机制尚未工作
    49                                  
    50 00000079 0F20C0                  	mov eax,cr0
    51 0000007C 6683C801                	or eax,1
    52 00000080 0F22C0                  	mov cr0,eax                        ;设置PE位
    53                                  
    54                                  	;以下进入保护模式... ...
    55 00000083 EA[8800]1000            	jmp 0x0010:flush                   ;16位的描述符选择子：32位偏移
    56                                  									   ;清流水线并串行化处理器
    57                                  ;---------- 保护模式准备结束 --------
    58                                  
    59                                  ;以下使用32位指令编码
    60                                  ;进入32位保护模式
    61                                  [bits 32]
    62                                  flush:
    63                                  	;设置数据段访问范围
    64 00000088 B808000000              	mov eax,0x0008
    65 0000008D 8ED8                    	mov ds,eax			;DS指向4GB内存空间
    66                                  	
    67                                  	;设置栈段访问范围
    68 0000008F B818000000              	mov eax,0x0018
    69 00000094 8ED0                    	mov ss,eax
    70 00000096 29E4                    	sub esp,esp	;esp=0，指针向下递减，0xffffffff开始往下递减
    71                                  	
    72                                  	;先读取一个扇区，获得程序头部内容和部分其他指令或数据
    73 00000098 BF00000400              	mov edi,core_base_address
    74 0000009D 89FB                    	mov ebx,edi						;内核在内存中的位置
    75 0000009F B801000000              	mov eax,core_start_sector		;内核逻辑扇区号
    76 000000A4 E890000000              	call read_logical_sector
    77                                  
    78                                  	;计算占用扇区数量
    79                                  	;64位除法，EDX:EAX(被除数) / ECX(除数)  = EAX(内核所占扇区数量)......EDX(根据是否有余数情况进行不同的处理)
    80 000000A9 29D2                    	sub edx,edx		;高32位没有用到，所以为0
    81 000000AB 8B07                    	mov eax,[edi]	;低32位，DS目前指向的是0~4GB数据段，edi作为偏移量访问内存
    82                                  					;这里取得的是内核程序总长度
    83 000000AD B900020000              	mov ecx,512
    84 000000B2 F7F1                    	div ecx			;EAX=内核所占扇区数量，EDX=根据余数情况判断是否扇区数需要+1
    85                                  	
    86                                  	;检查余数是否为0
    87 000000B4 83FA00                  	cmp edx,0
    88 000000B7 7401                    	je @no_remainder		;如果为0，则不需要额外读取一个扇区
    89                                  
    90                                  	;有余数需要额外读取一个扇区
    91 000000B9 40                      	inc eax
    92                                  	
    93                                  @no_remainder:
    94 000000BA 48                      	dec eax			;减去已经预读的扇区
    95                                  	
    96                                  	;如果eax=0, 说明用户程序小于等于512字节(扇区数为0)，直接进入主流程
    97 000000BB 83F800                  	cmp eax,0
    98 000000BE 7410                    	jz setup
    99                                  	
   100                                  	;否则根据已有扇区数循环读取数据，调read_logical_sector过程，把内核程序都放到内存中
   101 000000C0 89C1                    	mov ecx,eax		;需要循环读取的扇区数
   102 000000C2 B801000000              	mov eax,core_start_sector
   103 000000C7 40                      	inc eax			;从下一个逻辑扇区接着读
   104                                  	
   105                                  @loop_read:
   106 000000C8 E86C000000              	call read_logical_sector
   107 000000CD 40                      	inc eax
   108 000000CE E2F8                    	loop @loop_read
   109                                  
   110                                  ;安装段描述符，要做的事情就是找到内存中的GDT，修改它并重新载入
   111                                  setup:
   112 000000D0 8B35[9E7D0000]          	mov esi,[0x7c00+pgdt+0x02]		;获得GDT的基地址
   113                                  	
   114                                  	;建立内核api例程段描述符
   115 000000D6 8B4704                  	mov eax,[edi+0x04]				;内核core_api代码段起始汇编地址
   116 000000D9 8B5F08                  	mov ebx,[edi+0x08]				;内核core_data数据段的汇编地址
   117 000000DC 29C3                    	sub ebx,eax
   118 000000DE 4B                      	dec ebx							;内核api代码段的界限 = 内核数据段起始汇编地址 - 内核api段的起始汇编地址 - 1
   119 000000DF 01F8                    	add eax,edi						;内核api段的基地址 = 内核加载地址 + 内核api段的起始汇编地址
   120                                  	;准备参数：EAX存放基地址 EBX存放段界限 ECX存放各属性
   121 000000E1 B900984000              	mov ecx,0x00409800				;段属性：P=1(段存在) D=1(32位操作) G=0(字节粒度) DPL=0(特权级0) S=1(代码段) TYPE=1000(只执行)
   122 000000E6 E893000000              	call make_gdt_descriptor		;调用过程制作描述符
   123                                  	;描述符紧接着之前的描述存放
   124 000000EB 894628                  	mov [esi+0x28],eax
   125 000000EE 89562C                  	mov [esi+0x2c],edx
   126                                  	
   127                                  	;建立核心数据段描述符
   128 000000F1 8B4708                  	mov eax,[edi+0x08]                 ;核心数据段起始汇编地址
   129 000000F4 8B5F0C                  	mov ebx,[edi+0x0c]                 ;核心代码段汇编地址 
   130 000000F7 29C3                    	sub ebx,eax
   131 000000F9 4B                      	dec ebx                            ;核心数据段界限
   132 000000FA 01F8                    	add eax,edi                        ;核心数据段基地址
   133 000000FC B900924000              	mov ecx,0x00409200                 ;字节粒度的数据段描述符 
   134 00000101 E878000000              	call make_gdt_descriptor
   135 00000106 894630                  	mov [esi+0x30],eax
   136 00000109 895634                  	mov [esi+0x34],edx 
   137                                  
   138                                  	;建立核心代码段描述符
   139 0000010C 8B470C                  	mov eax,[edi+0x0c]                 ;核心代码段起始汇编地址
   140 0000010F 8B1F                    	mov ebx,[edi+0x00]                 ;程序总长度
   141 00000111 29C3                    	sub ebx,eax
   142 00000113 4B                      	dec ebx                            ;核心代码段界限
   143 00000114 01F8                    	add eax,edi                        ;核心代码段基地址
   144 00000116 B900984000              	mov ecx,0x00409800                 ;字节粒度的代码段描述符
   145 0000011B E85E000000              	call make_gdt_descriptor
   146 00000120 894638                  	mov [esi+0x38],eax
   147 00000123 89563C                  	mov [esi+0x3c],edx
   148                                  	
   149 00000126 66C705[9C7D0000]3F-     	mov word [0x7c00+pgdt],63		;描述符表界限，现在有8个描述符
   149 0000012E 00                 
   150                                  	
   151 0000012F 0F0115[9C7D0000]        	lgdt [0x7c00+pgdt]				;重新载入描述符表
   152                                  	
   153 00000136 FF6F10                  	jmp far [edi+0x10]				;跳转到内核程序入口点执行
   154                                  
   155                                  ;过程：读取一个逻辑扇区
   156                                  ;输入：EAX=逻辑扇区号，EAX是32位寄存器，可以一次性容纳28位逻辑扇区号
   157                                  ;	   DS:EBX=读取后的内容放置在内存中的位置，DS指定的数据段，EBX指定偏移地址
   158                                  ;	   每次读以512字节对齐，后续带来方便
   159                                  read_logical_sector:
   160 00000139 50                               push eax 
   161 0000013A 51                               push ecx
   162 0000013B 52                               push edx
   163                                           
   164 0000013C 50                      		 push eax
   165                                           
   166 0000013D 66BAF201                		 mov dx,0x1f2
   167 00000141 B001                             mov al,1
   168 00000143 EE                               out dx,al                       ;读取的扇区数
   169                                  
   170 00000144 6642                             inc dx                          ;0x1f3
   171 00000146 58                               pop eax
   172 00000147 EE                               out dx,al                       ;LBA地址7~0
   173                                  
   174 00000148 6642                             inc dx                          ;0x1f4
   175 0000014A B108                             mov cl,8
   176 0000014C D3E8                             shr eax,cl
   177 0000014E EE                               out dx,al                       ;LBA地址15~8
   178                                  
   179 0000014F 6642                             inc dx                          ;0x1f5
   180 00000151 D3E8                             shr eax,cl
   181 00000153 EE                               out dx,al                       ;LBA地址23~16
   182                                  
   183 00000154 6642                             inc dx                          ;0x1f6
   184 00000156 D3E8                             shr eax,cl
   185 00000158 0CE0                             or al,0xe0                      ;第一硬盘  LBA地址27~24
   186 0000015A EE                               out dx,al
   187                                  
   188 0000015B 6642                             inc dx                          ;0x1f7
   189 0000015D B020                             mov al,0x20                     ;读命令
   190 0000015F EE                               out dx,al
   191                                  
   192                                    .waits:
   193 00000160 EC                               in al,dx
   194 00000161 2488                             and al,0x88
   195 00000163 3C08                             cmp al,0x08
   196 00000165 75F9                             jnz .waits                      ;不忙，且硬盘已准备好数据传输 
   197                                  
   198 00000167 B900010000                       mov ecx,256                     ;总共要读取的字数
   199 0000016C 66BAF001                         mov dx,0x1f0
   200                                    .readw:
   201 00000170 66ED                             in ax,dx
   202 00000172 668903                           mov [ebx],ax
   203 00000175 83C302                           add ebx,2
   204 00000178 E2F6                             loop .readw
   205                                  
   206 0000017A 5A                               pop edx
   207 0000017B 59                               pop ecx
   208 0000017C 58                               pop eax
   209                                        
   210 0000017D C3                               ret
   211                                  
   212                                  ;制作段描述符
   213                                  ;输入：	EAX=线性基地址
   214                                  ;		EBX=段界限，只用低20位，因为段界限在段描述符格式中占20位
   215                                  ;		ECX=各属性，与描述符格式保持一致，无关的位都清0
   216                                  ;返回： EDX:EAX=完整的描述符
   217                                  make_gdt_descriptor:
   218                                  		;构造低32位
   219 0000017E 89C2                    		mov edx,eax			;线性基地址复制一份到edx中
   220 00000180 C1E010                  		shl eax,16			;左移16位使得基地址放在低32位中的高16位
   221 00000183 6609D8                  		or ax,bx			;低32位中的低16位存放段界限
   222                                  		
   223                                  		;清除基地址中无关的位
   224                                  		;如果不使用rol、bswap,仅使用shl、shr、and、or指令则代码会变得复杂一些
   225 00000186 81E20000FFFF            		and edx,0xffff0000			;保留edx中高16位，如果 edx = 0x12345678，执行该指令后edx=0x12340000
   226 0000018C C1C208                  		rol edx,8					;循环左移，最左边8位放在最右边, edx=34000012
   227 0000018F 0FCA                    		bswap edx					;字节交换指令[31:24] 与 [7:0] 交换；[23:16] 与 [15:8] 交换
   228                                  		
   229                                  		;装配段界限
   230 00000191 81E300000F00            		and ebx,0x000f0000
   231 00000197 09DA                    		or edx,ebx
   232                                  		
   233                                  		;装配属性
   234 00000199 09CA                    		or edx,ecx
   235                                  		
   236 0000019B C3                      		ret
   237                                  ;---------------------------------
   238                                  ;pgdt gdt的界限和起始物理地址
   239 0000019C 0000                    pgdt	dw 0
   240 0000019E 007E0000                		dd 0x00007e00
   241                                  ;---------------------------------
   242 000001A2 00<rep 5Ch>             times 510-($-$$) db 0
   243 000001FE 55AA                    				 dw 0xAA55
