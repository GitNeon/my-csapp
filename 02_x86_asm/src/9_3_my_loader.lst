     1                                  ;描述：程序加载器程序清单（位于主引导扇区）
     2                                  ;作者：fanx
     3                                  ;日期：2025.02.11
     4                                  
     5                                  user_program_start equ 100	;用户程序所在扇区起始位置，声明常数不占用汇编地址
     6                                  
     7                                  SECTION mbr align=16 vstart=0x7c00
     8                                  		;设置栈段 栈寄存器SS  栈指针SP
     9 00000000 B80000                  		mov ax,0
    10 00000003 8ED0                    		mov ss,ax
    11 00000005 89C4                    		mov sp,ax
    12                                  
    13                                  		;需要将物理地址转换为段地址:偏移地址形式
    14                                  		;由于地址是双字，需要两个寄存器来保存，DX放高位，AX放低位
    15                                  		;除以16分别，商为段地址(AX)，余数为偏移地址(DX)
    16 00000007 2EA1[CF00]              		mov ax,[cs:user_program_memory_address]
    17 0000000B 2E8B16[D100]            		mov dx,[cs:user_program_memory_address + 0x02]
    18 00000010 BB1000                  		mov bx,16
    19 00000013 F7F3                    		div bx
    20 00000015 8ED8                    		mov ds,ax
    21 00000017 8EC0                    		mov es,ax		;放入这两个寄存器后续使用
    22                                  
    23                                  		;调用read_logical_sector先读取用户程序头部内容
    24                                  		;也就是先读一个扇区(512字节)，包含头部信息和部分指令数据
    25                                  		;然后根据头部信息计算出还要在读多少个扇区
    26                                  		;准备该过程所需要的参数，也就是设置寄存器内容
    27 00000019 29FF                    		sub di,di					;寄存器DI清零0，保证高位数值正确
    28 0000001B BE6400                  		mov si,user_program_start	;传入常量
    29 0000001E 29DB                    		sub bx,bx					;BX清零，偏移地址存放在BX处
    30 00000020 E85200                  		call read_logical_sector
    31                                  
    32                                  
    33                                  		;计算占用的逻辑扇区数
    34                                  		;占用的逻辑扇区数 = 程序总长度 / 512字节
    35                                  		;此段逻辑相对于书中给出的程序进行了优化
    36 00000023 8B160200                		mov dx,[0x02]		;高16位
    37 00000027 A10000                  		mov ax,[0x00]		;低16位，DX:AX获得程序总长度
    38 0000002A BB0002                  		mov bx,512			;每个扇区512字节
    39 0000002D F7F3                    		div bx				;AX=商（扇区数），DX=余数（扇区数需要+1）
    40                                  
    41                                  		;判断是否需要额外读取一个扇区
    42 0000002F 83FA00                  		cmp dx,0			;检查余数是否为0
    43 00000032 7401                    		je @no_remainder	;如果为0，则不需要额外读取一个扇区
    44                                  							
    45                                  
    46                                  		;有余数需要额外读取一个扇区
    47 00000034 40                      		inc ax
    48                                  
    49                                  	@no_remainder:
    50 00000035 48                      		dec ax			;减去已经预读的扇区
    51                                  
    52                                  		;如果ax=0, 说明用户程序小于等于512字节(扇区数为0)，直接进入主流程
    53 00000036 83F800                  		cmp ax,0
    54 00000039 7413                    		jz main
    55                                  
    56                                  		;否则根据已有扇区数循环读取数据，调read_logical_sector过程，把用户程序都放到内存中
    57 0000003B 1E                      		push ds			;以下要用到ds寄存器，所以先保存到栈中
    58 0000003C 89C1                    		mov cx,ax		;需要循环读取的扇区数
    59                                  
    60                                  	@loop_read:
    61 0000003E 8CD8                    		mov ax,ds		;|
    62 00000040 83C020                  		add ax,0x20		;| 紧挨着上一个数据段尾构造一个新的512字节段，这样做是避免用户程序太大而导致产生段内数据覆盖
    63 00000043 8ED8                    		mov ds,ax		;|
    64                                  		
    65 00000045 29DB                    		sub bx,bx		;每次偏移地址从0x0000开始
    66 00000047 46                      		inc si			;下一个逻辑扇区
    67 00000048 E82A00                  		call read_logical_sector
    68 0000004B E2F1                    		loop @loop_read
    69                                  
    70 0000004D 1F                      		pop ds			;恢复ds寄存器地址到用户头部段
    71                                  
    72                                  	;主入口处理流程
    73                                  	main:
    74 0000004E 8B160800                		mov dx,[0x08]
    75 00000052 A10600                  		mov ax,[0x06]	;用户程序入口点段地址
    76 00000055 E85E00                  		call calc_segment_base
    77 00000058 A30600                  		mov [0x06],ax	;将逻辑段基址存放到原来的位置中
    78                                  		
    79                                  		;处理所有的段重定位表
    80 0000005B 8B0E0A00                		mov cx,[0x0a]	;表项数量
    81 0000005F BB0C00                  		mov bx,0x0c		;表起始地址
    82                                  		
    83                                  	loop_relocation:
    84 00000062 8B5702                  		mov dx,[bx+0x02]	;起始地址高16位
    85 00000065 8B07                    		mov ax,[bx]			;起始地址低16位
    86 00000067 E84C00                  		call calc_segment_base
    87 0000006A 8907                    		mov [bx],ax			;回填基地址
    88 0000006C 83C304                  		add bx,4			;下一个重定位表项，每个表项占4字节
    89 0000006F E2F1                    		loop loop_relocation
    90                                  		
    91 00000071 FF2E0400                		jmp far [0x04]		;转移到用户入口点
    92                                  
    93                                  	;过程：读取逻辑扇区
    94                                  	;输入：DI:SI=起始逻辑扇区号（28位），DI存放高12位(高12位左侧加0扩展到16位)，SI存放低16位
    95                                  	;	   DS:BX=数据放置位置，DS指定的数据段，BX指定偏移地址
    96                                  	read_logical_sector:
    97 00000075 50                      		push ax
    98 00000076 53                      		push bx
    99 00000077 51                      		push cx
   100 00000078 52                      		push dx	
   101                                  		
   102                                  		;(1)设置要读取的扇区数量
   103 00000079 BAF201                  		mov dx,0x1f2
   104 0000007C B001                    		mov al,0x01
   105 0000007E EE                      		out dx,al
   106                                  		
   107                                  		;(2)设置LBA扇区号，28位的扇区号太长，需要将其分成4段，分别写入端口0x1f3、0x1f4、0x1f5和0x1f6
   108                                  		; |0x1f6	   |0x1f5       |0x1f4       |0x1f3
   109                                  		; 0000_0000    0000_0000    0000_0000    0000_0000
   110                                  		; 位27~24      位23~16		位15~8		 位7~0
   111                                  		
   112                                  		;写入LBA地址7~0
   113 0000007F BAF301                  		mov dx,0x1f3
   114 00000082 89F0                    		mov ax,si
   115 00000084 EE                      		out dx,al
   116                                  		
   117                                  		;写入地址15~8
   118 00000085 42                      		inc dx
   119 00000086 88E0                    		mov al,ah
   120 00000088 EE                      		out dx,al
   121                                  		
   122                                  		;写入地址23~16
   123 00000089 42                      		inc dx
   124 0000008A 89F8                    		mov ax,di
   125 0000008C EE                      		out dx,al
   126                                  		
   127                                  		;写入地址27~24，并设置为LBA模式
   128 0000008D 42                      		inc dx
   129 0000008E B0E0                    		mov al,0xe0
   130 00000090 08E0                    		or al,ah
   131 00000092 EE                      		out dx,al
   132                                  		
   133                                  		;(3)请求硬盘读取数据
   134 00000093 BAF701                  		mov dx,0x1f7
   135 00000096 B020                    		mov al,0x20
   136 00000098 EE                      		out dx,al
   137                                  		
   138                                  		;(4)等待读写操作完成
   139 00000099 BAF701                  		mov dx,0x1f7
   140                                  	waits:
   141 0000009C EC                      		in al,dx
   142 0000009D 2488                    		and al,0x88
   143 0000009F 3C08                    		cmp al,0x08
   144 000000A1 75F9                    		jnz waits
   145                                  			
   146 000000A3 B90001                  		mov cx,256		;总共要读取的字数
   147 000000A6 BAF001                  		mov dx,0x1f0	;从这个数据端口读取数据
   148                                  		
   149                                  	readw:
   150 000000A9 ED                      		in ax,dx
   151 000000AA 8907                    		mov [bx],ax
   152 000000AC 83C302                  		add bx,2
   153 000000AF E2F8                    		loop readw
   154                                  
   155 000000B1 5A                      		pop dx
   156 000000B2 59                      		pop cx
   157 000000B3 5B                      		pop bx
   158 000000B4 58                      		pop ax
   159                                  	  
   160 000000B5 C3                      		ret
   161                                  	
   162                                  	;过程：计算段基址
   163                                  	;输入：DX:AX=32位物理地址
   164                                  	;输出：AX=16位逻辑段地址
   165                                  	;注意：尽管DX:AX中是32位的用户程序起始物理内存地址，理论上，
   166                                  	;它只有20位是有效的，低16位在寄存器AX中，高4位在寄存器DX的低4位。
   167                                  	calc_segment_base:
   168 000000B6 1E                      		push ds
   169                                  		
   170 000000B7 2E0306[CF00]            		add ax,[cs:user_program_memory_address]
   171 000000BC 2E1316[D100]            		adc dx,[cs:user_program_memory_address + 0x02]		;别忘了DX,AX中的内容还要基于加载的物理地址
   172 000000C1 C1E804                  		shr ax,4			;AX中内容右移4位，高位补0
   173 000000C4 C1CA04                  		ror dx,4			;循环移位，把低四位移到高4位
   174 000000C7 81E200F0                		and dx,0xf000		;将寄存器低12位清零
   175 000000CB 09D0                    		or ax,dx			;由于AX高4位为空，DX低四位有值，所以使用or指令合并这两个寄存器内容
   176                                  							;现在AX中存放的就是16位逻辑地址
   177 000000CD 1F                      		pop ds
   178                                  		
   179 000000CE C3                      		ret
   180                                  		
   181                                  mbr_end:
   182                                  
   183 000000CF 00000100                user_program_memory_address	dd 0x10000	;用户程序所在内存加载的物理地址
   184                                  
   185                                  ;前面没使用部分用0填充，最后2字节代表主引导扇区结束标志
   186                                  ;$代表当前汇编地址
   187                                  ;$$代表当前汇编节（段）的起始汇编地址
   188 000000D3 00<rep 12Bh>            times 510-($-$$) db 0
   189 000001FE 55AA                    dw 0xAA55
