#### 加载器工作流程

****

##### 1、初始化

加载想要加载一个用户程序，必须知道两点内容：

- 找到内存中什么地方是空闲的，即从哪个物理内存地址处开始加载用户程序。
- 确定用户程序所在硬盘上的存储位置，即它的起始逻辑扇区号是多少，需要读取多少个扇区。

##### 2、可用的内存范围

![](.\imgs\14-可用的内存范围.png)

- 物理地址0x0FFFF以下，是加载器及其栈的势力范围。
- 物理地址A0000以上，是BIOS和外围设备的势力范围，有很多传统的老式设备将自己的存储器和只读存储器映射到这个空间。
- 综上，我们可用的内存空间范围为10000~9FFFF，即加载器应当把用户程序加载到这个内存空间中去。

##### 3、计算加载用户程序逻辑段地址

​	这一段汇编程序(只展示重要部分代码)所做的就是把具体的物理地址转换成“段地址：偏移地址”。这样，我们就确定了用户程序要被加载到内存中的哪个位置上。

```assembly
phy_base dd 0x10000		;用户程序被加载的物理起始地址

SECTION mbr align=16 vstart=0x7c00 
	
	;设置栈段、栈指针起始位置 SS:SP = 0x0000:0x0000
	mov ax,0
	mov ss,ax
	mov sp,ax
	
	;将物理地址转换成逻辑地址，也就是段地址：偏移地址形式
	;利用除法进行右移获得段地址
	;得到的商就是段地址保存在AX中，AX=0x1000
	;余数为偏移地址DX=0x0000
	mov ax,[cs:phy_base]
	mov dx,[cx:phy_base+0x02]		;获得32位物理地址(DX:AX)除以16
	mov bx,16
	div bx
	...
	...
mbr_end:
```

图例：取得物理地址

![](.\imgs\15-取得物理地址.png)

##### 4、通过端口访问硬盘

- 加载器的下一步要进行的是从硬盘读取用户程序，也就是说需要和硬盘打交道。
- CPU可以通过端口来和I/O设备交换数据。

图例：处理器通过输出输出控制设备集中器(ICH)来IO设备通讯

![](.\imgs\16-IO设备.png)

端口：本质是位于I/O接口上的寄存器，端口的宽度可以是8位的，也可以是16位的。

端口的分配：Intel只允许65536个端口存在，端口号从0~65535（0x0000~0xffff）

端口的读写：不能使用mov指令，取而代之的是in和out指令

硬盘分配的端口号：ICH芯片内部通常集成了两个PATA/SATA接口，分别是主硬盘接口和副硬盘接口。

- 主硬盘接口分配的端口号是0x1f0～0x1f7，
- 副硬盘接口分配的端口号是0x170～0x177。

##### 5、in和out指令

**in指令：**

in指令是从端口读数据，目标操作必须是寄存器AL(8位)或AX(16位)，源操作数是DX，用来指定端口号

```assembly
in al,dx	;dx存放的是端口号，读入1字节的数据到al寄存器中
in ax,dx	;读入2字节的数据到ax寄存器中
```

也可以直接给出要访问的端口号：

```assembly
in al,0xf0
in ax,0x30
```

需要注意的是，in指令不允许内存地址作为操作数。

**out指令：**

out指令向外围设备发送数据

```assembly
out 0x37,al		;向0x37号端口发送寄存器al中的数据(1字节)
out 0xf5,ax		;向0xf5号端口发送寄存器ax中的数据(2字节)
```

```assembly
out dx,al		;发送寄存器al中的数据，说明端口为8位
out dx,ax		;发送寄存器ax中的数据，说明端口为16位
```

##### 6、通过硬盘控制器端口读扇区数据

- 硬盘的读写单位是扇区，使得主机与硬盘的数据交换是成块的。
- CHS模式：从硬盘读写数据，向硬盘控制器分别发送磁头号、柱面号、扇区号。
- LBA模式：逻辑扇区，将扇区统一编址，从0开始。
  - LBA28：使用28bit来表示逻辑扇区号，从逻辑扇区0x0000000~0xFFFFFFF，共可以表示2^28 = 268435456个扇区，每个扇区512字节，容量128G。
  - LBA48：使用48bit表示逻辑扇区号，可以管理131072TB硬盘容量。

##### 7、一段读写硬盘的汇编程序

- 要从硬盘上读取逻辑扇区，需要设置读取的扇区数量、设置起始LBA扇区号。
- 扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。

① 设置要读取的扇区数量：

```assembly
mov dx,0x1f2
mov al,0x01		;如果写入0，则表示读取256个扇区
out dx,al		;设置读取1个扇区，写入0x1f2端口号
				;不从0x1f0端口号开始写入是因为，这个端口号用于数据读写
				;不从0x1f1端口号开始写入是因为，这个端口号用于报告硬盘错误
```

② 设置起始LBA扇区号(LBA28)

28位的扇区号太长，需要将其分成4段，分别写入端口0x1f3、0x1f4、0x1f5和0x1f6

```asm
mov dx,0x1f3
mov al,0x02		;假设起始扇区号为0x02
out dx,al		;写入LBA地址0~7位

inc dx			;端口号+1，0x1f4
mov al,0x00
out dx,al		;LBA地址8~15位

inc dx			;0x1f5
out dx,al		;LBA地址16~23位

inc dx
mov al,0xe0		;0xe0 = 1110_0000B
out dx,al		;设置LBA模式，主硬盘，LBA地址24~27位
```

图例：LBA逻辑扇区号在各个端口号存放情况

![](.\imgs\17-lba地址存放情况.png)

其中端口0x1f6含义如下：

- 低4位用于存放逻辑扇区号的最后4位
- 第4位表示从主硬盘还是从硬盘读写数据
- 剩下3位表示CHS模式还是LBA模式

![](.\imgs\18-0x1f6端口各位含义.png)

③ 请求读硬盘，向0x1f7端口写入0x20

```assembly
mov dx,0x1f7
mov al,0x20		;读命令
out dx,al
```

④ 等待读写完成

```assembly
	mov dx,0x1f7
waits:
	in al,dx
	and al,0x88		;10001000B
	cmp al,0x08		;00001000B,走到这一步就是判断DRQ标志位是否为1
	jnz waits		;等待硬盘准备好数据且不忙
```

图例：0x1f7各位含义

![](.\imgs\19-0x1f7含义.png)

⑤ 连续取出数据

```assembly
mov cx,256		;按字读取，512字节需要读取256次
mov dx,0x1f0	;0x1f0是数据端口，一旦硬盘控制器空闲，且准备就绪，
				;就可以连续从这个端口写入或者读取数据
read_word:
	in ax,dx
	mov [bx],ax		;读取的数据存放到由段寄存器DS指定的数据段,偏移地址由寄存器BX指定
	add bx,2
	loop read_word
```

