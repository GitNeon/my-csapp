#### 第一个引导程序

****

- 程序自然要在屏幕上输出显示、我们才能知道运行状态、提示信息等
- 我们需要了解如何在屏幕上输出文字内容

##### 1、显卡和显存

- 要显示的内容都需要写到显存中（VRAM，Video RAM）
- 显卡有文本模式、图形模式，我们学习过程重点在于文本模式。
- 文本模式可以方便的直接输入ASCII码显示对应字符，图形模式则需要显示控制bit位。

**字符的显示：**

![](.\imgs\8-字符的显示.png)

- 操作显存里的比特，使得屏幕上能显示出字符的形状，是非常麻烦、非常烦琐的工作。
- 可以将字符的代码存放到显存里，这样只需提供字符的ASCII码，通过字符发生器就能在屏幕上显示字符。

**显示黑白图像：**

![](.\imgs\7-显存显示内容.png)

- 0表示不亮，1表示亮，将显存中的每个比特和显示器的每个像素对应起来，就能显示黑白图像。
- 显存的第1字节对应着屏幕左上角连续的8个像素；第2字节对应着屏幕上后续的8个像素，后面的依次类推。
- 显卡的工作是周期性地从显存中提取这些比特，并把它们按顺序显示在屏幕上。如果是比特“0”，则像素保持原来的状态不变，因为屏幕本来就是黑的；如果是比特“1”，则点亮对应的像素。

**显示彩色：**

- 黑色和白色只需要1比特就能表示，但要显示更多的颜色，1比特就不够了。
- 需要3个字节，即24bit来对应一个像素。因为2^24 = 16777216，可以显示这么多种颜色。

**文本模式下显存映射到内存空间：**

- 由于历史的原因，所有在个人计算机上使用的显卡，在加电自检之后都会把自己初始化为80×25的文本模式。在这种模式下，屏幕上可以显示25行，每行80个字符，每屏总共2000个字符。
- 8086可以访问1MB内存。其中，0x00000～9FFFF属于常规内存，由内存条提供；0xF0000～0xFFFFF由主板上的一个芯片提供，即ROM-BIOS。
- 中间320KB空间即0xA0000～0xEFFFF区域由特定外围设备提供，这其中就包括显卡。
- 一直以来，0xB8000～0xBFFFF这段物理地址空间，是留给显卡的，由显卡来提供，用来显示文本。

![](.\imgs\9-显存内存映射.png)

**显存的地址：**

- 访问显存也需要逻辑地址，采用“段地址：偏移地址”形式
- 文本模式下显存起始物理地址为0xB8000，可以看成段地址为0xB800，偏移地址从0x0000延伸到0xFFFF的区域。

##### 2、显示字符

​	屏幕上的每个字符对应着显存中连续2字节，前一个是字符的ASCII代码，后面是字符的显示属性，包括字符颜色（前景色）和底色（背景色）。

![](.\imgs\10-显示字符.png)

![](.\imgs\11-字符属性格式.png)

![](.\imgs\12-颜色表.png)

- 字符的显示属性（1字节）分为两部分，低4位定义的是前景色，高4位定义的是背景色。
- 色彩主要由R、G、B这3位决定。
- K是闪烁位，为0时不闪烁，为1时闪烁；I是亮度位，为0时正常亮度，为1时呈高亮。

##### 3、一个显示字符的汇编程序

程序内容如下：

```assembly
;show_label.asm
mov ax,0xb800
mov ds,ax

mov byte [0x00], 'L'
mov byte [0x02], 'a'
mov byte [0x04], 'b'
mov byte [0x06], 'e'
mov byte [0x08], 'l'
mov byte [0x0a], ' '
mov byte [0x0c], 'o'
mov byte [0x0e], 'f'
mov byte [0x10], 'f'
mov byte [0x12], 's'
mov byte [0x14], 'e'
mov byte [0x16], 't'
mov byte [0x18], ':'

jmp $

; 填充空白字节
times 510-($-$$) db 0
dw 0aa55H
```

运行VMBox，显示效果如下：

![](.\imgs\13-labeloffset显示效果.png)

**该程序的注意事项：**

- 一个合法的主引导程序最后以0xAA、0x55两字节结尾。
- 每个字符属性占用两字节，只不过这里我们没有显示指定字符属性，因此默认为无闪烁无高亮。
- times用于重复db指令填充0。

##### 4、优化后的程序

上面程序实现了在主引导扇区中启动后显示label offset字符，但是还有两点问题需要优化。

- 字符和背景色的彩色显示；
- 采用数据定义指令(db、dw)来定义数据段，采用循环读字符串并显示。

下面是优化后的程序：

```assembly
;显示彩色的Label offset:
jmp near start

showText db 'L','a','b','e','l',' ','o','f','f','s','e','t',':'

start:	mov ax,0xb800
		mov es,ax			;显示缓冲区所在段地址

		mov bx,0x7c00		;主引导程序是在内存0x0000:0x7c00处开始加载的,因此一定不要忘记加上这个地址

		mov cx,start - showText			;获得循环次数
		mov si,showText
		mov di,0

loopstr:mov byte al, [bx+si]		;先取得原有字符
		mov byte ah, 0x17			;设置颜色格式,蓝底白字
		mov [es:di],ax				;复制单个字符到显示缓冲区
		inc si
		add di,2
		loop loopstr

	
jmp near $

times 510-($-$$) db 0
db 0x55,0xaa
```

