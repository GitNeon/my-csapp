# 8086汇编语言笔记

- 配套教材：王爽《汇编语言 第四版》
- 视频教程：[贺立坚-8086汇编语言](https://www.bilibili.com/video/BV1Wu411B72F)

## 前置知识

在学习汇编语言之前，需要了解一些相关知识，有助于我们后续学习：

#### 1、汇编语言的产生

- 早期计算机由机器码编写，全部是二进制，例如：10001011，不方便人们的理解和记忆，于是产生了汇编语言

- 汇编语言就是助记符，方便人们理解和记忆、使用，汇编语言的主体是汇编指令

- 对于如下指令：

  - 操作：寄存器 BX 的内容送到 AX 中
  - 机器指令：1000100111011000
  - 汇编指令：mov ax,bx

- 汇编语言不能被计算机识别，想要使用它，就必须得转换成机器语言：

  ![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\001-汇编语言转换成机器语言过程.png)

#### 2、汇编语言的组成

汇编语言的核心就是汇编指令，它决定了汇编语言的特性

- 汇编指令：机器码的助记符，有对应的机器码
- 伪指令：没有对应的机器码，由编译器理解并执行，计算并不执行
- 其他符号：如算术用的，+、-、*、/等，有编译器识别，没有对应机器码

#### 3、指令和数据

- 指令和数据是我们逻辑应用上的概念，在计算机存储器（内存或硬盘上）中都是二进制存放的，关键在于是如何使用和看待它的

例子：对于如下二进制，既可以看作**指令**，又可以看作**数据**

1000100111011000  -> 89D8H(数据)
1000100111011000  -> mov ax,bx(程序)

#### 4、存储单元的划分

存储单位：

- 位(bit)：即能存储一个0或1，是存储信息的最小单位表示形式
- 字节(Byte)：8个bit组成一个1个字节，2^8=256，一个字节可以表示最多256中状态

存储单元：

- 存储单元是个笼统的概念，取决于具体场景下对它的划分。在最小表示情况下，一个存储单元可以存储一个字节，即8个二进制位，若一个存储器有128个存储单元，则它可以存储128个Byte。

常见的单位容量换算：

- 1KB = 1024B
- 1MB = 1024KB
- 1GB = 1024MB
- 1TB = 1024GB

存储单元的划分：

- 如果一个存储器有128个存储单元，则它存储128个字节（1024位）。对存储单元进行编号就是0~127

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\002-存储单元的划分.png)

#### 5、CPU对存储器的读写

CPU如果想要和存储器，尤其是内存进行读写数据，就必须通过总线发出三种信息：

- 地址信息：通过地址总线传输要读写的内存单元地址
- 数据信息：通过数据总线传送读或写的数据
- 控制信息：CPU发出的控制信号，告诉内存此次操作是读出还是写入

**总线：地址总线、数据总线、控制总线这三者合称为系统总线，所谓总线就是传输数据用的一根根物理导线**

例子：CPU从3号内存单元中读写数据的过程

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\003-CPU读取内存单元数据过程.png)

读过程：

- CPU 通过地址线将地址信息3发出。
- CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。
- 存储器将3号单元中的数据8通过数据线送入 CPU。

写过程：

- CPU 通过地址线将地址信息3发出。
- CPU 通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入
  数据。
-  CPU 通过数据线将数据 26 送入内存的3号单元中。

#### 6、CPU通过三种总线传输数据的示意图

通过地址总线传输地址信息：

- 一个 CPU 有 N 根地址线，则可以说这个 CPU 的地址总线的宽度为 N。这样的 CPU
  最多可以寻找 2 的 N 次方个内存单元。
- 

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\004-传输地址信息.png)

8088CPU通过数据总线传输数据过程：

- 由于8088CPU数据总线只有8位，因此传送16位数据时需要分两次传送

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\005-8088CPU传送数据过程.png)

8086CPU通过数据总线传输数据过程：

- 8086CPU有16根数据总线，一次即可传输完毕

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\006-8086传输过程.png)

## 一、寄存器

#### 1、寄存器介绍

8086CPU有14个寄存器，每个寄存器有16位，可以存放两个字节。

它们的说明和作用如下：

**通用寄存器（4个）：**

- **AX（Accumulator，累加器）**
  - 主要用于乘除运算、BCD运算、换码、I/O操作、串操作、中断调用等。
  - 可分为AH（高8位）和AL（低8位）两部分单独使用。
- **BX（Base，基址寄存器）**
  - 主要用于存放地址、基址（默认相对于DS段）。
  - 也可用来存放数据和地址。
- **CX（Counter，计数器）**
  - 主要用于循环计数、串操作计数、移位计数（CL）等。
- **DX（Data，数据寄存器）**
  - 主要用于16位乘除、间接I/O、中断调用等。
  - 可分为DH（高8位）和DL（低8位）两部分单独使用。

需要注意的是：AX、BX、CX、DX这四个寄存器<span style="color: red">都可以用来存放普通数据，但是又有各自的独特功能</span>

**段寄存器（4个）：**

- **CS（Code Segment，代码段寄存器）**
  - 用于存放正在或正待执行的程序段的起始地址的高16位二进制数据，即程序段的段地址。
- **DS（Data Segment，数据段寄存器）**
  - 用于存放正在或正待处理的一般数据段的起始地址的高16位二进制数据，即一般数据段的段地址。
- **SS（Stack Segment，堆栈数据段寄存器）**
  - 用于存放正在或正待处理的堆栈数据段的起始地址的高16位二进制数据，即堆栈数据段的段地址。
- **ES（Extra Segment，附加数据段寄存器）**
  - 用于存放正在或正待处理的附加数据段的起始地址的高16位二进制数据，即附加数据段的段地址。

**指令指针和变址寄存器（5个）：**

- **SP（Stack Pointer，堆栈指针）**
  - 主要用于存放栈顶地址。
  - 当向堆栈内压入数据时，SP寄存器的值会自动减少；当从堆栈内弹出数据时，SP寄存器的值会自动增加。
- **BP（Base Pointer，基址指针）**
  - 主要用于存放地址、基址（默认相对于SS段）。
  - 可以作为一个索引寄存器，用于访问数组和表格元素。
- **SI（Source Index，源变址寄存器）**
  - 用于存放地址、变址、串操作源变址。
- **DI（Destination Index，目的变址寄存器）**
  - 用于存放地址、变址、串操作目的变址。

- **IP（Instruction Pointer，指令指针）**
  - 用来存放将要执行的下一条指令在现行代码段中的偏移地址。
  - 其内容始终是下一条待执行指令的起始偏移地址，与CS一起形成下一条待执行指令的起始物理地址。

**标志寄存器（1个）：**

- **PSW（Program Status Word，程序状态字）或Flags（标志寄存器）**
  - 用来存放运算结果的特征。
  - 包括3个控制标志（IF、DF、TF）和6个状态标志（SF、PF、ZF、OF、CF、AF）。这些标志通常用于条件分支指令和算术指令的判断。

了解以上8086CPU14个寄存器的作用，才能明白编写汇编语言时对寄存器操作的规则。

#### 2、寄存器结构

8086所有寄存器都是16位的，这里以AX为例，它的结构如下：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\01-ax寄存器结构.png)

特点：

- 一个16位寄存器可以存储16位(bit)的数
- 为了保持上代CPU兼容性，8086CPU的AX、BX、CX、DX这4个寄存器可以拆分为两个独立的8位寄存器使用
  - AX 可分为 AH 和 AL;
  - BX 可分为 BH 和 BL;
  - CX 可分为 CH 和 CL;
  - DX 可分为 DH 和 DL。

数据在寄存器中存放的例子：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\02-数据在寄存器中存放的例子.png)

寄存器分为两个8位寄存器使用：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\03-寄存器分为8位使用.png)

**字**在寄存器中的存储：

- 字节:记为 byte，一个字节由8个bit组成，可以存在8位寄存器中。
- 字:记为 word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\04-字的组成.png)

自然的，AH存储高8位，AL存储低8位。这个既可以整体看待成一个数，也可以单独看待成两个字

#### 3、寄存器的搭配使用

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\05-寄存器配合使用.png)

在进行操作CPU寄存器时，根据不同的场景和用途可以归纳以下表格：

| 操作类型   | 隐含的段地址寄存器 | 可替换的段地址寄存器 | 偏移地址所在寄存器                                      |
| ---------- | ------------------ | -------------------- | ------------------------------------------------------- |
| 取指令     | CS                 | -                    | IP                                                      |
| 栈操作     | SS                 | CS、DS、ES           | 有效地址（Effective Address）<br>可配合BP、SP寄存器使用 |
| 存取变量   | DS                 | CS、DS、ES           | 有效地址                                                |
| 源字符串   | DS                 | CS、DS、ES           | SI                                                      |
| 目标字符串 | ES                 | -                    | DI                                                      |

#### 4、8086CPU合成物理地址

CPU访问内存单元时，必须给出实际的物理地址，在向地址总线发出地址前，必须在CPU内部合成实际的物理地址。

8086CPU是16位结构的，有如下特性：

- CPU内部运算器一次最大处理的数据位数为16位
- 寄存器最大宽度为16位，即一次最大存储16位数据
- 寄存器和运算器之间的通路为16位

8086CPU物理结构为16位，那么它的地址寻址能力只有64KB（2^16 = 65536个不同的内存地址，内存通常以字节为单位组织，1KB=1024Byte，65536/1024=64KB）。

要想达到1MB的寻址能力，则需要合成20位物理地址，**8086CPU内部采用段地址+偏移地址合成20位物理地址**

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\06-8086CPU合成物理地址.png)

**合成地址过程：**

- CPU 中的相关部件提供两个 16 位的地址，一个称为段地址，另一个称为偏移地址;
- 段地址和偏移地址通过内部总线传入地址加法器；
- 地址加法器合成20位的物理地址；
- 地址加法器通过内部总线将20位物理地址传送到输入输出控制电路；
- 输入输出控制电路将 20位物理地址送上地址总线；
- 20位物理地址被地址总线传送到存储器。

例子：8086CPU 要访问地址为123C8H的内存单元，它的工作过程如下：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\07-地址加法器过程.png)

总结：

- 对于二进制来说，左移1位就是乘以2；那么一个数据的二进制形式左移N位就是相当于乘以2^N次方
- 一个数据的十进制形式左移1位，相当于乘以 10
- 一个数据的十六进制形式左移1位，相当于乘以 16
- 一个X进制的数据左移1位，相当于乘以X。

<span style="color:red">地址合成公式=（段地址SA×16）+偏移地址EA=物理地址</span>	

#### 5、段的划分

说明：

- 内存物理上并不分段，“段”的划分是逻辑上的概念，来自于CPU的划分
- 段的起始地址又称`基础地址`，和段地址是不同的概念（因为根据公式得知，段地址×16才是段的起始地址）

例如：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\08-分段.png)

- 将起始地址为10000H，结束地址为100FFH的内存范围划分为一个段，这段内存地址是连续的
- 划分多个段：10000H~1007FH为一个段，10080H~100FFH为另外一个段

以后在编程时，用段地址×16定位段的起始地址，用偏移地址定位段中的内存单元。

注意：

- 段地址×16 必然是 16 的倍数，所以一个段的起始地址也一定是 16 的倍数;
- 偏移地址为 16 位，变化范围为0~FFFFH，寻址能力为 64KB，所以一个段的长度最大为 64KB。

**计算寻址范围：**

一定要熟记两点：一是物理地址计算公式（SA×16+EA）=物理地址，二是偏移地址寻址范围为0-FFFFH。

比如给定段地址 1000H，用偏移地址寻址，CPU的寻址范围为:10000H~1FFFFH。计算过程如下：

- 将1000H乘以16，左移一位，得到10000H，因为偏移地址的最小值为0，所以得到CPU最小寻址范围为10000H + 0H = 10000H
- 偏移地址的最大范围为FFFFH，因此，CPU最大寻址范围为10000H + FFFFH = 1FFFFH

**代码段：**

在编程时，可以根据需要，将一组连续的内存单元定义为一个段（逻辑上），存放数条代码。我们可以认为，这段内存是用来存放代码的，从而定义了一个代码段。CS寄存器存放了代码段的段地址

例如：

```assembly
mov ax,0000		(B8 00 00)
add ax,0123H	(05 23 01)
mov bx,ax		(8B D8)
jmp bx			(FF E3)
```

这段长度为 10 个字节的指令，存放在 123B0H~123B9H 的一组内存单元中，我们就可以认为123B0H~123B9H 这段内存是用来存放代码的，是一个代码段，它的段地址为123BH，长度为 10 个字节。

**数据段：**

同样的，如果将一个段内的内容看作数据，那么这个段可以被当作数据段。DS寄存器存放了数据段的段地址

#### 6、段寄存器

用**段地址×16+偏移地址**，获得CPU想要访问数据或指令的真实地址。那么我们就需要用到CPU中的寄存器来保存段地址和偏移地址。

根据笔记前面对寄存器的介绍和搭配使用，我们获得：

- 使用【CS】：代码段寄存器保存**段地址**
- 使用【IP】：指令指针寄存器保存**偏移地址**

通过CPU内部处理，获得真正的物理地址。

**地址合成及取指执行：**

8086CPU合成物理地址、执行一条指令的工作原理如下：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\09-合成物理地址过程.png)

【初始】：CPU执行一段程序时，CS代码段寄存器指定了该程序所在内存段中的段地址，IP指令指针寄存器指定了程序的初始偏移地址。CPU 将从内存 2000H×16+0000H 处读取指令执行；

【第一步】：CS、IP中的内容送入地址加法器(地址加法器完成：物理地址=段地址x16+偏移地址)；

【第二步】：地址加法器将物理地址20000H送入输入输出控制电路；

【第三步】：输入输出控制电路将物理地址 20000H送上地址总线，内存获得要访问数据的地址；

【第四步】：内存单元20000H位置开始的机器指令B82301通过数据总线送入CPU；

【第五步】：输入输出控制电路将机器指令 B8 23 01 送入指令缓冲器；

【第六步】：这时，读取一条指令后，IP 中的值自动增加，以使 CPU 可以读取下一条指令。因当前读入的指B8 

23 01长度为 3个字节，所以 IP 中的值加 3。此时，CS:IP 指向内存单元 2000:0003；

【第七步】：执行控制器执行指令 B8 23 01(即 mov ax,0123H)；

【第八步】：指令 B8 23 01 被执行后 AX 中的内容为 0123H。

以上就是8086CPU取指执行过程，CPU下次取指地址将会从2000：0003处开始。

通过上面的过程展示，8086CPU的工作过程可以简要描述如下：

（1）从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器:
（2）IP=IP+所读取指令的长度，从而指向下一条指令;
（3）执行指令。转到步骤(1)，重复这个过程。

**修改CS、IP指令：**

- CPU 从何处执行指令是由 CS、IP 中的内容决定的，通过改变CS、IP实现不同程序的执行，程序跳转执行等。
- mov 指令并不能直接修改CS、IP寄存器，8086CPU没有提供这样的功能。
- 8086CPU提供了 **转移指令**来修改CS、IP中的值：jmp 段地址: 偏移地址
  - 例如：jmp 2AE3:3，执行后:CS=2AE3H，IP=0003H，CPU 将从2AE33H 处读取指令
  - 例如：jmp 3:0B16，执行后:CS=0003H，IP=0B16H，CPU将从00B46H处读取指令。

#### 7、寄存器的内存访问

**内存中字的存储：**

内存中字的存储，要明确以下概念：

- 字：用16位寄存器来存储一个字，由于8086CPU寄存器都是16位的，因此，存储一个字需要一个寄存器。
- 内存单元：以字节单元为划分（1字节=8位），因此在内存中存储一个字需要**两个连续**的内存单元。**这个字的低位字节存放在低地址单元中，高位字节放在高地址单元中**。
- 字单元：由两个连续的内存单元组成，能够存储一个字型数据的内存单元被称为字单元。

内存中存放一个字：

![image-20241104170320575](C:\Users\Yunyan\AppData\Roaming\Typora\typora-user-images\image-20241104170320575.png)

我们很容易看出，这个字的高位字节放在高地址单元中，低位字节放在低地址单元中。

**给出访问内存单元的地址：**

CPU在访问一个内存单元的时候，必须给出一个实际的内存地址。8086CPU给出内存地址的示例汇编代码如下：

```asm
mov bx,1000H
mov ds,bx  ;ds寄存器通常用来存放要访问数据的段地址
mov al,[0] ;[]表示访问内存单元地址，[0]表示内存的偏移地址为0，相应的段地址在DS寄存器中
```

上面的三条指令将10000H（1000：0）中的数据读到al寄存器中

借助mov指令，我们可以完成：

- 将数据直接送入寄存器（DS、CS等寄存器无法直接送入）
- 将一个寄存器中的内容送入另一个寄存器

8086CPU通过段地址×16+偏移地址给出内存单元的实际地址，我们用[...]形式给出偏移地址，而CPU自动取DS寄存中的数据作为内存单元的段地址。

一个重要的结论：CPU想要从内存单元中获取数据或指令，就必须知道要访问内容的地址。DS寄存器通常用于存放要访问数据的段地址。

**字的传送：**

- 用mov al,[0]形式，将字节型数据传送到al寄存器。
- 8086CPU是16位结构的，所以可以一次性传送16位数据，也就是一个字的数据，只要mov指令中给出16位的寄存器即可。

```asm
mov bx,1000H	;将数据1000H送入到BX寄存器中
mov ds,bx		;将bx寄存器的值送入到ds寄存器中，此时，1000H将会被当作段地址使用
mov ax,[0]		;将1000:0处的字型数据送入ax寄存器中
mov [0],cx		;cx中的16位数据送到1000:0处
```

上面这段汇编语言，完成了一个字型数据的传送。

#### 8、栈机制

栈是一种先进后出的数据结构，下面是栈的图例：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\10-栈.png)

8086CPU同样的提供了相关的指令以栈的形式访问内存空间，这意味我们可以选取内存中的一段空间当作栈的形式来使用。

- 入栈指令：PUSH，例如push ax表示将ax寄存器中的内容送入栈中。
- 出栈指令：POP，例如pop ax表示从栈顶取出数据送入ax。
- 8086CPU的入栈和出栈操作都是以<span style="color:red">字</span>为单位进行的。

8086CPU出栈、入栈的内存操作过程：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\11-栈操作过程.png)

**栈段：**

前面我们了解过代码段、数据段，同样的栈段就是指将一段连续的内存地址空间当作栈来使用，专门用于操作出栈、入栈等。

**栈段寄存器：**

对于代码段来说，由CS:IP负责保存内存中代码段数据空间的基址和偏移地址；

对于数据段来说，由DS:[合法的访问地址]（SI、DI、BX等寄存器内部的值、或加法计算的值）来访问数据段；

那么同样的对于栈段来说，由SS:SP寄存器保存栈段的访问基址和偏移地址。

<span style="color:red">任意时刻，SS:SP指向栈顶元素。</span>PUSH、POP指令执行时，SP会发生变化，CPU会从SS:SP中得到最新的栈顶地址。

PUSH指令的执行过程，包含栈相关寄存器的变化：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\12-PUSH指令执行过程.png)

【初始】：初始状态下，已经存放了数据0123，当前栈顶地址为1000：000E；

【第一步】：执行push ax, SP中的内容将发生变化，SP=SP-2（存储一个字需要两个内存单元），此时，栈顶地址为1000：000C；

【第二步】：将AX寄存器中的数据送到SS:SP指向的内存单元处。

8086CPU入栈时，栈顶从高地址向低地址方向增长。

POP指令则和PUSH指令相反：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\13-pop.png)

**栈顶超界问题**

PUSH超界：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\14-push超界.png)

POP超界：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\15-pop超界.png)

- 栈超界是危险的，可能会覆盖掉栈空间之外的数据、代码，引发不可预知的错误。
- 8086CPU没有提供硬件级的限制，例如记录栈顶上限和栈底下限寄存器。
- 8086CPU只知道栈顶在何处，但不知道我们安排的栈空间有多大，所以在编程时需要程序员自己小心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小。

**PUSH、POP指令的合法格式：**

合法指令形式如下：

- push 寄存器	;将一个寄存器中的数据入栈
- pop 寄存器          ;用一个寄存器接收出栈的数据
- push 段寄存器    ;将一个段寄存器中的数据入栈
- pop 段寄存器      ;用一个段寄存器接收出栈的数据
- push 内存单元    ;将一个内存字单元处的字入栈
- pop 内存单元      ;用一个内存字单元接收出栈的数据

需要注意的是：

- 栈操作都是以字为单位；
- 用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。

## 二、汇编程序

#### 1、汇编程序分析

**从编写到执行：**

一个汇编程序从编写好到执行，是需要经历多个步骤的，我们仍然以这幅图为例：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\001-汇编语言转换成机器语言过程.png)

【第一步】：程序员首先通过文本编辑器,IDE等工具通过汇编语言编写程序源码；

【第二步】：编译器对源码进行翻译（即编译），产生编译中间目标文件，然后使用连接程序对这些目标文件进行连接，生成可在操作系统中直接运行的可执行文件。

可执行文件包含两种信息：

- 程序（翻译成的机器码）和数据（源程序中定义的数据）
- 相关的描述信息（程序的大小、占用的内存空间等）

【第三步】：执行可执行文件的程序，将可执行文件中的机器码和数据加载入内存，并进行初始化设置，比如设置CS：IP，指向该程序的第一条要执行的指令，然后CPU开始执行该程序。

程序经编译后变为机器码：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\16-程序经编译后变为机器码.png)

**分析一段源程序：**

```asm
assume cs:codesg

codesg segment
	mov ax,0123H
	mov bx,0456H
	add ax,bx
	add ax,ax
	
	mov ax,4c00H
	int 21H
codesg ends

end
```

上面一段汇编程序由汇编指令和伪指令，汇编指令可以被编译为机器指令，最终被CPU执行。而伪指令仅由编译器识别并执行。

【1】segment和ends伪指令

segment 和 ends 是一对成对使用的伪指令，功能是定义一个段，segment 说明一个段开始，ends说明一个段结束。一个段必须有一个名称(名称不是固定的)来标识。

```asm
codesg segment
...
codesg ends
```

- <span style="color:red">一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。</span>
- <span style="color:red">一个有意义的汇编程序至少需要一个段，这个段用来存放代码</span>
- 一个源程序中所有将被计算机所处理的信息：指令、数据、栈，被划分到了不同的段中。

特别注意的是：segment前的标号，作为一个段的名称，最终将被编译处理为一个段的段地址。

【2】end伪指令

编译器在编译汇编程序过程中，如果碰见end指令，就结束对源程序的编译，因此程序写完了必须加上end伪指令。

【3】assume伪指令

将我们编写的段程序与段寄存器相关联，例如代码段需要和CS寄存器关联，程序段需要和DS寄存器关联，栈段需要和SS寄存器关联。

#### 2、编辑、编译和连接

**编辑：**

可以使用文本编辑器来编写、修改源程序，最终将源程序存储为以asm结尾的文件

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\17-asm结尾的源文件.png)

**编译：**

【1】进入DOS系统，输入masm命令，提示我们输入要编译的源文件名称

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\18-1-编译asm.png)

【2】输入要编译的源程序文件名后（一般指明所在路径），按下回车键，产生*编译中间文件*，以.obj格式结尾

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\18-2-编译asm.png)

​	obj的文件名称会跟随源文件名称，因此如果没有重命名的要求，再次按下回车键即可。

【3】编译器继续生成中间文件，列表文件和交叉文件

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\18-3-编译asm.png)

​	这两个文件也不是我们需要关注的，因此继续按下回车键忽略即可。

【4】至此，如果源程序不存在语法错误，编译则成功

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\18-4-编译asm.png)

**连接：**

上面的编译过程产生了中间文件obj，但是还需要连接步骤，以生成真正的可执行exe文件

【1】继续在DOS命令模式下输入link命令，这时要求我们输入要连接的obj文件名称

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\19-1-连接obj.png)

【2】输入obj文件名称，可以省略后缀，如果不是以obj结尾则需要输入全名

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\19-2-连接obj.png)

【3】同样的，在连接阶段忽略产生的中间文件，直接按下回车键，直至出现一行警告（没有栈段，如果程序不要栈，可以忽略这个警告）。最终在当前路径下产生exe结尾的可执行文件。

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\19-3-连接obj.png)

连接程序的作用：

- 当源程序很大时，可以将它分割成多个文件来进行编译，最后再用连接程序连在一起，生成一个可执行文件。
- 程序中调用了某个库文件的内容，需要将这个库文件和生成的目标文件连接到一起，生成一个可执行文件。
- 无论如何，在编译时产生了中间目标文件，必须通过连接程序处理生成最后的可执行文件。

对于连接的过程，可执行文件是我们要得到的最终结果。

**简化的编译和连接过程：**

在使用masm或link命令是，结尾加入;号可以直接忽略中间文件，产生最终结果

```cmd
C:\masm>masm c:\program\mytest.asm;
```

```cmd
C:\masm>link mytest;
```

#### 3、程序运行过程中的跟踪

**DOS加载EXE应用程序的过程：**

程序被装入在内存的什么地方，我们如何得知？在进行debug调试应用程序之前，需要了解一下DOS加载exe应用程序的过程。

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\20-0-DOS加载EXE过程.png)

- 程序加载后，DS寄存器存放着程序所在内存区域的段地址，偏移地址为0，则程序所在的内存区的地址为DS:0
- 给定一片空闲的内存区域加载程序时，这个空闲区域的前256个字节存放的是程序段前缀PSP，用于和DOS系统通信。从256字节处向后的空间存放的是程序。

我们得到：

PSP的段地址是SA，偏移地址为0，物理地址=SA×16+0。

程序的物理地址=SA×16+0+256=SA+10H：0。

**DEBUG调试：**

可以使用debug命令观察程序的运行过程：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\20-1-debug.png)

【R命令】：查看各个寄存器的设置情况

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\20-2-debug.png)

CX寄存器存放该程序的长度，如果1.exe程序的机器码共有15个字节，那么CX中的内容为000FH。

DS寄存器存放的是该段程序所在内存区中某个划分段的段地址，DS=129E，则PSP的地址为129E：0，

程序的地址为12AE:0(129E+10:0)。

查看CS寄存器，程序的段地址为CS=12AE，偏移地址为IP=0000，CS:IP指向程序的第一条指令。

【U命令】查看程序更多信息

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\20-3-debug.png)

可以看到，从 12AE:0000~12AE:000E 都是程序的机器码。

【T命令、P命令】

T命令用于单步调试跟踪，到了int 21时，通过P命令结束程序，调试结束。

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\20-4-debug.png)

【Q命令】

使用Q命令推出返回到command命令行界面

**DEBUG常用命令总结：**

| 命令  | 说明                                                   | 示例                |
| ----- | ------------------------------------------------------ | ------------------- |
| debug | 调试可执行文件                                         | debug xxx.exe       |
| A     | 指定内存位置输入汇编语句                               | A 163B:1000         |
| U     | 指定内存范围中的机器码进行反汇编                       | U 076A:0000   0010  |
| R     | 查看寄存器中的内容<br />R 寄存器名称，可修改寄存器内容 | R<br />R 寄存器名称 |
| T     | 单步调试，每执行一条代码就会显示寄存器状态             | T                   |
| D     | 查看指定内存地址(开始)的内容                           | D 076A:0000         |
| E     | 修改指定内存地址(开始)内容                             | E 0010 'HELLO'      |

#### 4、包含多个段的程序

- 一个完整的汇编程序，可以包含多个段，例如代码段、数据段、栈段。
- 若要一个程序在被加载的时候取得所需空间，则必须在源程序中声明。我们通过定义不同段的方式来进行内存空间的获取。
- 划分多个段非常重要，可以避免程序变得混乱。

划分多个段的程序示例：

```asm
assume cs:code, ds:data, ss:stack

data segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
stack ends

code segment
 start:
 	...
 	...
 	...
code ends

end start
```

代码段、数据段、栈段完全是我们在编写程序的时候为了方便、清晰等才这么安排。CPU并不会直接识别这些段，CPU到底如何处理我们定义的段内容，完全是靠程序中的汇编指令，以及对CS:IP、SS:SP、DS等寄存器的设置来决定的。

例如：

```asm
mov ax,stack
mov ss,ax
mov sp,20H
```

设置 ss 指向 stack，设置 ss:sp 指向 stack:20，CPU 执行这些指令后，将把 stack 段当做栈空间来用。CPU 若要访问 data 段中的数据，则可用 ds 指向 data 段，用其他的寄存器(如 bx)来存放 data 段中数据的偏移地址。

## 三、内存访问

#### 1、内存单元访问

通过[...]实现对内存单元地址的访问，段地址默认在DS中。通过mov指令可以访问**段前缀:[...]**处内存单元内容，并传送到ax寄存器中。

```asm
mov ax,[bx]
```

例如：bx中存放的数据作为偏移地址，段地址默认在DS中，将SA:EA处的数据送到ax中。即(ax)=((ds)*16+(bx))。

> 用（）表示某个寄存器或单元地址中的内容
>
> - （ax）表示ax寄存器中的内容
> - （ds）表示ds寄存器中的内容
> - （2000H）表示内存单元2000H处的内容

使用常量：

```asm
mov ax,[0]		;[]内直接使用数字
```

我们还可以，将寄存器中内容回写到指定内存地址单元：

```asm
mov [bx],ax		;((ds)*16+(bx))=(ax)
```

总结

- 我们在访问内存单元时，有两种基本的方法，一种是用[]取BX寄存器中的值，另一种是取立即数常量。
- 内存单元的访问可以是：字节内存单元、字内存单元、双字内存单元。

**段前缀：**

出现在访问内存单元的指令中，用于显式地指明内存单元的段地址前缀，被称为段前缀。

```asm
mov ax,ss:[bx]	;显式指定ss寄存器
```

**访问安全的内存空间：**

在DOS系统下，0:200~02ff空间中没有系统或者其他程序的数据或代码，以后，我们需要直接向一段内存中写入内容时，就使用 0:200~0:2ff这段空间。(共256字节)

#### 2、更加灵活定位内存地址的方法

**[bx+idata]：**

[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata，其中idata表示一个立即数常量。

例如：

```asm
mov ax, [bx + 200]		; (ax) = ((ds)*16+(bx)+200)
;其他写法1	mov ax,[200+bx]
;其他写法2	mov ax,200[bx]
;其他写法3	mov ax,[bx].200
```

表示将段地址为DS寄存中的内容，偏移地址为bx寄存器中的数值加上200的内存单元地址处的数据送入到ax寄存器中（注意不要忘记，操作内存单元通常以一个字为单位，即字单元2字节）。

**SI、DI：**

前面我们介绍过SI、DI寄存器，这两个寄存器也可以通过[]取值访问内存地址单元。

实现了相同功能：

```asm
mov bx,0
mov ax,[bx]

mov si,0
mov ax,[si]

mov di,0
mov ax,[di]
```

也能和立即数常量配合使用：

```asm
mov bx,0
mov ax,[bx+123]

mov si,0
mov ax,[si+123]

mov di,0
mov ax,[di+123]
```

**[bx+si]和[bx+di]：**

bx寄存器可以和si、di寄存中的数值做加法，达到更加灵活的访问内存单元。这对于复制字符串场景更加实用。

```asm
mov ax,[bx+si]	;将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节(字单元)，存放一个字，
				;偏移地址为 bx 中的数值加上 si 中的数值，段地址在 ds 中。
```

也可以写作为：

```asm
mov ax,[bx][si]
```

**[bx+si+idata]和[bx+di+idata]：**

[bx+si+idata]表示一个内存单元，它的偏移地址为(bx)+(si)+idata(即 bx 中的数值加上si 中的数值再加上 idata)。

```asm
mov ax,[bx+si+idata]	;将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节(字单元)，存放一个
						;字，偏移地址为 bx 中的数值加上 si 中的数值再加上 idata，段地址在 ds 中。
```

也可以写作为：

```asm
mov ax,idata[bx][si]	;idata表示立即数
mov ax,[bx][si].idata
```

#### 3、内存寻址指令规则

用[]进行内存单元寻址时，需要注意以下几点：

- []内能使用的寄存器有BX、SI、DI、BP，除此之外使用其他寄存器是错误的
- []中包含BP时，默认段前缀是基于SS寄存器的。
- 使用[BX]、[SI]、[DI]时，默认段前缀基于DS寄存器

组合使用寄存器时，以下指令是正确的：

```asm
mov ax,[bx+si]
mov ax,[bx+di]
mov ax,[bp+si]
mov ax,[bp+di]
mov ax,[bx+si+idata]
mov ax,[bx+di+idata]
mov ax,[bp+si+idata]
mov ax,[bp+di+idata]
```

以下指令是非法的：

```asm
mov ax,[bx+bp]
mov ax,[si+di]
```

包含BP寄存器时，默认段前缀为SS，段地址在SS中

```asm
mov ax,[bp]				;含义:(ax)=((ss)*16+(bp))
mov ax,[bp+idata]		;含义:(ax)=((ss)*16+(bp)+idata)
mov ax [bp+si]			;含义:(ax)=((ss)*16+(bp)+(si))
mov ax,[bp+si+idata]	;含义:(ax)=((ss)*16+(bp)+(si)+idata)
```

#### 5、寻址方式

定位内存单元的方法称作为寻址方式，8086CPU有多种寻址方式

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\21-寻址方式.png)

## 四、数据处理

#### 1、指令要处理的数据存储位置

存在三个地方：CPU内部、内存、端口

例如：

- mov bx,[0]	;数据存放在内存单元DS:0处
- mov bx,ax        ;数组存放在CPU内部寄存器中
- in al,20h            ;从20h端口读入一个字节

#### 2、处理数据长度

8086CPU可以处理字操作(2字节，16位)、字节操作(1个字节，8位)。

**字操作：**

由于操作的寄存器长度都是16位的，因此寄存器指明了进行的是字操作。

```asm
mov ax,1
mov bx,ds:[0]
mov ds,ax
mov ds:[0],ax
inc ax
add ax,1000
```

**字节操作：**

下面的指令中，寄存器指明了指令进行的是字节操作。

```asm
mov al,1
mov al,bl
mov al,ds:[0]
mov ds:[0],al
inc al
add al,100
```

**显式指定长度：**

在没有寄存器参与的内存单元访问指令中，用word ptr和byte ptr显式指明访问长度是非常重要的。

byte ptr：

```asm
mov ax,2000H
mov ds,ax
mov byte ptr [1000H],1
;该地址对应的内存中的内容变为：
;2000:1000 01 FF FF FF FF FF ...
```

word ptr：

```asm
mov ax,2000H
mov ds,ax
mov word ptr [1000H],1
;内容变为：
;2000:1000 01 00 FF FF FF FF ...
```

可见，针对字的操作，修改的是DS:1000H和DS：1001H两个单元的内容。

此外：有些指令默认指定了访问的是字操作，例如push指令。

#### 3、伪指令定义数据

**DB、DW、DD指令：**

【db】define byte，定义字节类型变量，一个字节数据占1个字单元，读完一个，偏移量加1

【dw】define word，定义字类型变量，一个字数据占2个字节单元，读完一个，偏移量加2

【dd】double word，定义双字类型变量，一个双字占4个字节单元，读完一个，偏移量加4

定义数据的几种形式如下：

- 字符，汇编语言中，字符串通常存储为一系列的ASCII码值，每个字符占一个字节。
- 字符串，由多个字符组成。
- 字节数值数组。
- 数字（汇编语言源程序中的数字默认是10进制，使用十六进制时，后缀必须带H）

以DB为例：

```asm
;data.asm
assume cs:code, ds:data

data segment
	db 'a'						;定义字符，占一个字节
	db 'ABCDEF'					;定义字符串，占用6个字节
	db 'A','B','C','D','E','F'	;多个字符，占6个字节，相当于上面定义的字符串
	db 0,1,2,3,4,5,6,7			;分别表示要定义的8个字节的值
	db 255						;8位表示的最大数值
data ends

code segment
	start:mov ax,data
		  mov ds,ax
		  
		  mov ax,4c00h
		  int 21h
code ends
end start
```

进入DOSBOX，使用masm命令编译该程序，使用link命令链接为可执行程序exe。

使用debug data.exe进入调试：

使用-t进行单步调后，将data数据段送入ax寄存器，ax寄存器送入ds寄存器，通过-d 就能查看真正的数据内容了，操作图例如下：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\22-debug-data-asm.png)

我们可以看到：

- 定义的数据在内存中是按顺序紧挨着存放的，内存单元地址是连续的。
- 字符会被转换为ASCII码对应的数值在内存中存放。
- 定义的字节数值数组，即使只有一个数字，也是占一个字节。
- 单个字节定义的最大数值为255(十进制)，在内存中表现为FF（十六进制）。

**dup指令：**

dup也是有编译器识别处理的符号，它用于重复定义数据。

定义了3个字节，它们的值都是0，相当于 db 0,0,0。

```asm
db 3 dup (0)
```

定义了9个字节，相当于db 0,1,2,0,1,2,0,1,2

```asm
db 3 dup (0,1,2)
```

应用场景：在定义大容量栈段时，比如定义200个字节的栈段，这个指令就非常好用了，会让代码变得简洁。

```asm
stack segment
	db 200 dup (0)
stack ends
```

## 五、几个常见的汇编指令

#### 1、MOV指令

mov指令用于数据传送，格式如下：

| 语法                    | 示例       |
| ----------------------- | ---------- |
| mov    寄存器, 数据     | mov ax,8   |
| mov    寄存器，寄存器   | mov ax,bx  |
| mov    寄存器，内存单元 | mov ax,[0] |
| mov    内存单元, 寄存器 | mov [0],ax |
| mov    段寄存器, 寄存器 | mov ds,ax  |
| mov    寄存器，段寄存器 | mov ax,ds  |

#### 2、ADD、SUB指令

add、sub指令用于两个操作对象的相加或相减，用法和MOV指令类似，但需要的注意的是不能对段寄存器作相加减

```asm
add ax,8
add ax,bx
add ax,ax
add ax,[0]
add [0],ax	;将内存单元地址为0的数据内容于ax寄存器中的内容相加，并写回到地址0处
add ax,1234H	;直接相加一个立即数也是合法的

add ds,ax	;非法操作，段寄存器不能参与算术运算
```

#### 3、LOOP指令

loop指令用于循环处理，相当于高级语言中的for循环。

- 指令格式：loop 标号

loop指令做两方面的操作，一是将CX寄存器中的值-1，(cx)=(cx)-1，二是判断CX中的值，不为零则转至标号处执行程序，如果为零则向下执行。

编程实现2^12：

```asm
assume cs:code

code segment
	mov ax,2
	mov cx,11
	
  s:add ax,ax
  	loop s			;执行到这里作两步操作，一是(cx)=(cx)-1，二是判断cx的值是否为0，不为0跳转到s标号
  					;继续执行，否则向下执行
  	
  	mov ax,4c00h
  	int 21h
code ends

end
```

用cx和 loop 指令相配合实现循环功能的程序框架如下：

```asm
mov cx,循环次数
s:
	循环执行的程序段
	...
	loop s
```

#### 4、AND和OR指令

**AND指令**

【规则】：逻辑与指令，按位进行与运算

【用法技巧】：使用这个指令可以将操作对象的相应位设为0，其他位不变。

```asm
mov al,01100011B
and al,00111011B

;执行后，al=00100011B
```

**OR指令**

【规则】：逻辑或指令，按位进行或运算

【用法技巧】：通过该指令可将操作对象的相应位设为1，其他位不变。

```asm
mov al,01100011B
or al,00111011B

;执行后 al=01111011B
```

#### 5、PUSH、POP指令

PUSH用于压栈，POP用于出栈操作

- push 寄存器
- pop 寄存器
- push 段寄存器
- pop 段寄存器
- push 内存单元
- pop 内存单元

用法示例：

```asm
push ax		;将ax寄存器中的数据入栈
pop bx		;出栈，用一个寄存器接收出栈的数据

push ds		;将一个段寄存器中的数据入栈
pop ds		;出栈，用一个段寄存器接收出栈的数据

push [0]	;将1000:0处的字压入栈中
pop [2]		;出栈，出栈的数据送入 1000:2处
			;未显式指定段前缀时，CPU自动从DS寄存器取得
```

#### 6、DIV指令

div指令用于做除法应用，有几个注意点：

【除数】：存放在一个寄存器或内存单元中，可以是8位，也可以是16位。

【被除数】：

- 如果除数为8位，被除数则为16位，默认在AX寄存器中存放。
- 如果除数为16位，被除数则为32位，在DX和AX寄存器中存放，DX存放高16位，AX存放低16位。

【计算结果】：

- 如果除数为8位，AL寄存器存储商，AH寄存器存放余数。
- 如果除数为16位，AX寄存器存储商，DX寄存器存放余数。

div指令格式：

```asm
div 寄存器
div 内存单元
```

例子：

```asm
div byte ptr ds:[0]		
;除以8位
;含义：(ax)/((ds)*16+0)   (al)=商  (ah)=余数`
```

```asm
div byte ptr [bx+si+8]	
;除以8位，寄存器相对基址变址寻址
;含义：(ax)/((ds)*16+(bx)+(si)+8) (al)=商 (ah)=余数
```

```asm
div word ptr es:[0]
;除以16位
;含义：[(dx)*10000H + (ax)] / ((es)*16+0) (ax)=商 (dx)=余数
;dx为16位寄存器，乘以10000H变成32位。具体来说16位寄存器最大值位2^16-1=65536D，也就是10000H，左移16位变成32位数
```

```asm
div word ptr [bx+si+8]
;除以16位，相对基址变址寻址
;含义：[(ds)*10000H+(ax)]/((ds)*16+(bx)+(si)+8) (ax)=商  (dx)=余数
```

#### 7、MUL指令

mul指令用于乘法运算。

【乘数】：两个相乘的数，要么都是8位，要么都是16位。

- 8位乘数，一个默认放在AL寄存器中，另一个放在8位寄存器或者字节内存单元中。
- 16位乘数，一个默认在AX寄存器中，另一个放在16位寄存器或内存字单元中。

【结果】：结果可能是16位或者32位。

- 8位乘法：结果默认放在AX中。
- 16位乘法：高位放DX，低位放AX。

mul指令格式：

```asm
mul reg
mul 内存单元
```

内存单元可以用不同的寻址方式给出，比如：

```asm
mul byte ptr ds:[0]
;(ax)=(al)*((ds)*16+0)

mul word ptr [bx+si+8]
;(ax)=(ax)*((ds)*16+(bx)+(si)+8) 结果的低16位
;(dx)=(ax)*((ds)*16+(bx)+(si)+8) 结果的高16位
```

例子：

8位乘法：

```asm
;计算：100*10
;结果：(ax)=1000(03E8H)
mov al,100
mov bl,10
mul bl
```

16位乘法：

```asm
;计算：100*10000
;结果：(ax)=4240H (dx)=000FH (F4240H=1000000)
mov ax,100
mov bx,10000
mul bx
```

## 六、转移指令

#### 1、转移指令介绍

概念：可以修改IP，或者同时修改CS和IP的指令统称为转移指令。

特点：可以控制CPU执行内中某处代码的指令。

根据转移指令分类：

- 无条件转移（例如：jmp指令）
- 条件转移指令
- 循环指令
- 过程
- 中断

根据转移行为分类：

- 段内转移：只修改偏移地址，也就是IP寄存器的内容。
- 段间转移：同时修改CS和IP寄存器中的内容。

根据转移范围分类(针对IP)：

- 短转移：IP的修改范围为-128~127。
- 近转移：IP的修改范围为-32768~32767。

#### 2、offset操作符

这个操作符有编译器解释并处理，功能是获取标号处的偏移地址

```asm
assume cs:codesg

codesg segment
	start: mov ax, offset start		;相当于mov ax,0
		s: mov ax, offset s			;相当于mov ax,3
codesg ends

end
```

#### 3、无条件转移指令

jmp指令为无条件转移指令，也就是说跳转到目标地址执行代码不需要满足什么触发条件。

jmp指令只可以修改IP，也可以同时修改CS和IP。

jmp指令需要给出两种信息：

- 转移的目的地址
- 转移的距离（段间转移、段内短转移、段内近转移）

**基本转移：**

mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能，但是提供了jmp指令来修改这两个寄存器中的值。

同时修改CS、IP，格式：jmp 段地址:偏移地址，

功能：（CS）=(段地址)，（IP）=(偏移地址)

```asm
jmp 2AE3:3	;执行后：CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令
jmp 3:0B16	;执行后：CS=0003H，IP=0B16H，CPU将从00B46H处读取指令
```

仅修改IP内容，格式：jmp 16位寄存器：

功能：（IP）=（寄存器的值）

```asm
jmp ax	;指令执行前：ax=1000H,CS=2000H,IP=0003H
		;指令执行后：ax=1000H,CS=2000H,IP=1000H
```

**段内短转移：**

功能：(IP)=(IP)+8位位移

```asm
assume cs:codesg

codesg segment
	start: mov ax,0
		   jmp short s	;short说明指令进行的是短转移
		   add ax,1
		s: inc ax
codesg ends

end start	;有标号时需要指定结束的标号位置
```

**转移原理探究：**

将上面的汇编程序以debug方式调试，用U命令查看机器码如下：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\23-debug-jmp-1.png)

机器码`EB03`并没有包含要转移的目的地址，而是给出了要转移的位移数03。

<span style="color:red">其实，CPU在执行jmp指令时并不需要转移的目的地址，而是给出了要转移的位移量。</span>

回顾CPU执行指令的过程：

- 从 CS:IP 指向内存单元读取指令，读取的指令进入指令缓冲器；
- (IP)=(IP)+所读取指令的长度，从而指向下一条指令;
- 执行指令。转到1，重复这个过程。

那么jmp short s指令的执行过程如下：

- （CS）=0BBDH，（IP）=0003H。CS:IP指向EB03（jmp short s的机器码）；
- 读取指令码EB 03 进入指令缓冲器
- （IP）=(IP)+所读取指令长度，由于add ax,1占2个字节，因此（IP）+2=0005H，CS:IP指向add ax,1;
- CPU执行指令缓冲器中的指令EB03
- 指令EB03执行后，(IP)=(IP)+JMP指令产生的位移数03=0008，CS:IP指向inc ax。

转移位移计算方法：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\23-转移指令计算方法.png)

对于jmp short总结：

- 位移 = 标号处地址 — jmp指令后第一个字节的地址；
- short指明位移为8位，范围位-128~127，用补码表示；
- 位移由编译程序在编译时计算出。

**段内近转移：**

功能：(IP)=(IP)+16位位移

```asm
codesg segment
	start: mov ax,0
		   jmp near ptr s	;near ptr说明指令进行的是近转移
		   add ax,1
		s: inc ax
codesg ends
```

- 位移 = 标号处地址 — jmp指令后第一个字节的地址；
- near ptr指明此处位移为16位位移，进行的是段内近转移，位移范围为-32768~32767，用补码表示；
- 位移由编译程序在编译时计算出。

**转移地址在内存中的段内转移：**

指令格式：`jmp word ptr` 内存单元地址（段内转移）

功能：（IP）=（内存单元地址开始处的一个字内容）

例如：

```asm
mov ax,0123H
mov ds:[0],ax
jmp word ptr ds:[0]
;执行后，(IP)=0123H
```

```asm
mov ax,0123H
mov [bx],ax
jmp word ptr [bx]
;执行后，(IP)=0123H
```

**转移地址在内存中的段间转移：**

指令格式：`jmp dword ptr`内存单元地址

功能：（CS）=（内存单元地址+2），（IP）=（内存单元低地址）

解释：这个指令从内存单元地址处开始寻得两个字的内容，高地址(2字节)处的字存放的是转移目标的段地址，低地址(2字节)存放的是转移目标的偏移地址。

例如：

```asm
mov ax,0123H
mov ds:[0],ax
mov word ptr ds:[2],0
jmp dword ptr ds:[0]
;执行后 (CS)=0,(IP)=0123H, CS:IP指向0000:0123
```

```asm
mov ax,0123H
mov [bx],ax
mov word ptr [bx+2],0
jmp dword ptr [bx]
;执行后 (CS)=0,(IP)=0123H,CS:IP指向0000:0123
```

**段间转移：**

jmp far ptr又称为远转移，修改CS和IP。

（CS）=标号所在段的段地址，（IP）=段中的偏移地址

```asm
mov ax,0
mov bx,0
jmp far ptr s
db 256 dup(0)
s: add ax,1
   inc ax
```

Debug中调试该程序：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\24-far-ptr-机器码.png)

`jmp far ptr s`对应的机器码是`EA 0B 01 BD 0B`，包含了转移的段地址和偏移地址。

- 高地址`BD 0B`是转移的段地址`0BBDH`。
- 低地址`0B 01`是转移的偏移地址`010BH`。

#### 4、有条件转移指令

jcxz 指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对的修改范围都为:-128~127。

指令格式：`jcxz 标号`，如果(cx)=0，则转移到标号处执行。

其功能就像 C 语言所描述的代码：if ((cx) == 0 ) jmp short 标号。

示例：利用 jcxz 指令，实现从CS（段地址）中查找第一个值为0的字节，并把偏移地址存储在dx寄存器中

```asm
assume cs:code
code segment
start:
    mov ax, cs
    mov ds, ax
    mov bx, 0
s:  mov cx, 0       ;重置cx
    mov cl, [bx]    ;cl = ds:[bx]指向的内存单元中的值
    jcxz ok         ;cx = 0则跳转到标号ok处执行指令，否则该指令什么都不做，CPU继续顺序执行下一条指令
    inc bx
    jmp short s     ;jmp无条件转移的短转移指令，跳转到标号s处执行指令
 
ok: mov dx, bx
    mov ax, 4c00h
    int 21h    
code ends
end start
```

#### 5、loop指令

前面笔记提到了loop指令的用法，这里在补充一下loop指令关于转移的知识点。

loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对的修改范围都为:-128~127。

指令格式：loop 标号

操作：

- (cx) = (cx) - 1;
- 如果(cx)≠0，(IP) = (IP) + 8位位移（8位位移=标号处地址-loop指令后第一个字节的地址）。

#### 6、根据位移转移的意义

转移指令不直接包含要转移的目的地址，而是包含位移数，这种设计其实为了程序更加灵活加载到内存当中的任意位置。

例如：

```asm
mov cx,6	;机器码 B9 06 00
mov ax,10h	;B8 10 00
s:add ax,ax	;01 C0
loop s		;E2 FC
```

​	这段程序装在内存中的不同位置都可正确执行，因为1oops在执行时只涉及s的位移(-4，前移4个字节，补码表示为 FCH)，而不是s的地址。如果 loops的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制，因为机器码中包含的是s的地址，如果s处的指令不在目的地址处，程序的执行就会出错。而1oops的机器码中包含的是转移的位移，就不存在这个问题了，因为，无论s处的指令的实际地址是多少，loop 指令的转移位移是不变的。

#### 7、ret和retf指令

这两个指令有点类似于高级语言中的函数调用。当一个函数被调用时，它会进入栈中，函数执行完毕时，会出栈，并返回(return)到调用点。

**ret指令(return)：**

功能：用栈中的数据，修改IP的内容，从而实现近转移。

操作：

- (IP) = ((ss)*16+(sp))
- (sp) = (sp) + 2

假设IP寄存器能使用pop指令，CPU执行ret指令就相当于：pop IP。

```asm
assume cs:code

stack segment
	db 16 dup (0)
stack ends

code segment
	mov ax,4c00h
	int 21h
start:mov ax,stack
	  mov ss,ax
	  mov sp,16
	  mov ax,0
	  push ax		;执行入栈，占了两个内存单元 （sp）=(sp)-2
	  mov bx,0
	  ret			;修改IP的值=0000，栈的指针+2 (sp)=(sp)+2
code ends

end start
```

**retf指令(return far)**：

功能：用栈中的数据，修改CS和IP中的内容，从而实现远转移。

操作：

- (IP) = ((ss)*16+(sp))
- (sp)=(sp)+2
- (CS)=((ss)*16+(sp))
- (sp)=(sp)+2

CPU执行retf指令就相当于：pop IP，pop CS。

```asm
assume cs:code

stack segment
	db 16 dup (0)
stack ends

code segment
    mov ax,4c00h
    int 21h
    start:
    mov ax,stack
    mov ss,ax
    mov sp,16
    mov ax,0
    push cs
    push ax		;两次push连续入栈两次
    mov bx,0
    retf		;出栈，IP=第一次出栈字型数据，CS=第二次出栈字型数据
code ends

end start
```

#### 8、call指令

这个指令通常和上面的ret和retf指令配合使用，call意思是调用，类似于高级语言中的函数调用。

功能：将当前的IP或CS和IP压入栈中，然后转移。

注意：call指令不能实现短转移。

**根据位移进行转移的call指令：**

格式：call 标号

功能：近转移，将当前的IP压入栈后，转到标号处执行指令

操作：

- (sp)= (sp) - 2

  ((ss)*16+(sp)) = (IP)

- (IP) = (IP)+16位位移

16位位移=标号处的地址 - call指令后的第一个字节的地址，位移范围为-32768~32767。

CPU执行"call 标号"时，相当于进行：

push IP

jmp near ptr 标号

**转移目的地址在指令中的call指令：**

格式：call far ptr 标号

功能：段间转移，将当前的CS、IP压入栈中，然后转到标号处执行指令（修改CS、IP）

操作：

- (sp) = (sp) - 2

  ((ss)*16+(sp)) = (CS)

  (sp)=(sp)-2

  ((ss)*16+(sp))=(IP)

- (CS) = 标号所在段的段地址

  (IP) = 标号在段中的偏移地址

CPU执行“call far ptr 标号”时，相当于进行：

push CS

push IP

jmp far ptr 标号

**转移地址在寄存器中的call指令：**

指令格式：call 16位reg

功能：将IP压入栈中，然后转到标号处执行内容（修改IP寄存器）

操作：

- (sp)=(sp)-2

  ((ss)*16+(sp))=(IP)

- (IP)=(16位reg)

CPU执行“call 16位reg”时，相当于：

push IP

jmp 16位reg

**转移地址在内存中的call指令：**

格式：call word ptr、call dword ptr

功能：从内存单元中获得转移地址，单字仅修改IP，双字修改CS、IP（高地址对应CS寄存器，低地址对应IP寄存器）

例子：

call word ptr

```asm
mov sp,10h
mov ax,0123h
mov ds:[0],ax
call word ptr ds:[0]
;相当于：push IP，jmp word ptr 内存单元地址
; 执行后，(IP)=0123H,(SP)=0EH
```

call dword ptr 内存单元地址

```asm
mov sp,10h
mov ax,0123h
mov ds:[0],ax
mov word ptr ds:[2],0
call dword ptr ds:[0]
;相当于push CS,push IP,jmp dword ptr 内存单元地址
;执行后,(CS)=0,(IP)=0123H,(SP)=0CH
```

#### 9、call指令和ret指令配合使用

使用call指令实现对子程序的调用，使用ret指令实现子程序的返回。

具有子程序的源程序框架如下：

```asm
assume cs:code

code segment
	main:
		...
		...
		call sub1	;调用子程序sub1
		...
		...
		mov ax,4c00h
		int 21h
	sub1:
		...
		...
		call sub2	;调用子程序sub2
		ret			;子程序返回
	sub2:
		...
		...
		ret			;子程序返回
code ends

end main
```

一个带有子程序的程序执行过程：

```asm
assume cs:code
code segment
	start: 
		mov ax,1
		mov cx,3
		call s
		mov bx,ax	;(bx)的值是多少？
		mov ax,4c00h
		int 21h
	s:
		add ax,ax
		loop s
		ret
code ends
end start
```

- CPU将call s指令的机器码读入，IP自增，指向了mov bx,ax；
- 执行call s指令，将当前IP值压栈，并将IP寄存器中的值改变为标号处的偏移地址
- CPU从标号s处开始执行指令，loop循环完毕后，(ax)=8
- CPU将ret指令的机器码读入，IP自增，指向了ret指令后的内存单元
- CPU执行ret指令，从栈中弹出一个值（即先前压入栈中的mov ax,bx指令的偏移地址）送入IP中，则CS:IP指向指令mov bx,ax
- CPU从mov bx,ax开始执行指令，直至完成。

## 七、标志寄存器

#### 1、几个标志位的介绍

CPU内部存在一种特殊的寄存器：标志寄存器，它能影响CPU的工作行为，具有以下3种作用：

- 用来存储相关指令的某些执行结果；
- 用来为CPU执行相关指令提供行为依据；
- 用来控制CPU的相关工作方式。

8086CPU寄存器结构如下图：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\25-flag寄存器.png)

寄存器共有16位，每一位代表不同的含义，其中第1、3、5、12、13、14、15位没有用到，不具任何含义。

在8086CPU的指令集当中，有的指令会影响标志寄存器：

运算指令：例如add、sub、mul、div等指令能够影响标志寄存器。

传送指令则没有影响。

| 标志位 | 含义       | 说明                                                       |
| ------ | ---------- | ---------------------------------------------------------- |
| ZF     | 零标志位   | ZF=1表示结果为0，ZF=0表示结果不为0                         |
| PF     | 奇偶标志位 | 计算结果中1的个数，偶数PF=1，奇数PF=0                      |
| SF     | 符号标志位 | 计算结果是否为负，为负SF=1，非负SF=0                       |
| CF     | 进位标志位 | 记录了无符号数运算结果最高有效位向更高位的进位值或借位值   |
| OF     | 溢出标志位 | 记录了有符号数的运算结果是否发生溢出，OF=1溢出，OF=0未溢出 |
| DF     | 方向标志位 | 控制si、di的方向，是递增还是递减                           |

**进位标志位的进位说明：**

​	对于位数为 N 的无符号数来说，其对应的二进制信息的最高位，即第 N-1 位，就是它的最高有效位，而假想存在的第 N 位，就是相对于最高有效位的更高位，如图所示：

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\26-假想进位.png)

​	当两个数据相加的时候，如果最高位产生了进位，那么多余的进位值无法在结果中保存（位数溢出），而是记录在一个特殊的寄存器的某一位上。8086CPU就用flag寄存器中的CF位记录这个进位值。

```asm
mov al,98H
add al,al	;执行后 (al)=30H，CF=1，CF记录了最高有效位向更高位的进位值
add al,al	;再次相加，执行后(al)=60H，CF=0
```

```asm
mov al,97H
sub al,98H	;借位值，执行后(al)=FFH,CF=1 表示最高位借1
```

**CF和OF的区别：**

- CF是针对无符号数运算有意义的标志位
- OF是对有符号数运算有意义的标志位

对于以下加法而言：

```asm
mov al,98
add al,99
```

​	CPU 在执行 add 等指令的时候，就包含了两种含义：无符号数运算和有符号数运算。对于无符号数运算，CPU 用 CF 位来记录是否产生了进位；对于有符号数运算，CPU 用 OF 位来记录是否产生了溢出，当然，还要用 SF 位来记录结果的符号。对于无符号数运算，98+99 没有进位，CF=0;对于有符号数运算，98+99 发生溢出，OF=1。

​	CF 和 OF 所表示的进位和溢出，是分别对无符号数和有符号数运算而言的，它们之间没有任何关系。

**CLD和STD：**

8086CPU提供了两条指令对DF位的值进行设置

CLD指令：设置DF=0

STD指令：设置DF=1

格式：cld、std

#### 2、adc指令

adc指令用于带进位的加法

指令格式：adc 操作对象1，操作对象2

功能：操作对象1 = 操作对象1 + 操作对象2 + CF （例如：(ax) = (ax) + (bx) + CF）

例子：

```asm
mov ax,2
mov bx,1
sub bx,ax	;减法产生借位，CF=1
adc ax,1	;相当于(ax)+1+CF=2+1+1=4
```

```asm
mov ax,1
add ax,ax	;未产生进位，CF=0
adc ax,3	;相当于(ax)+3+CF = 2+3+0=5
```

```asm
mov al,98H
add al,al	;加法产生进位,CF=1
adc al,3	;相当于(al)+3+CF=30H+3+1=34h
```

有了adc指令，我们可以进行大数值的加法运算：可以分两步来进行，①低位相加，②高位相加再加上进位值。

例1：编程计算1EF000H+201000H，结果放在ax(高16位)，bx(低16位)中。

```asm
;将这两个加数按照每4位进行划分,不足4位的前面补0
;	001E F000
; +	0020 1000
;——————————————
;	003F 0000
mov ax,001EH
mov bx,0F000H	;注意这里，由于汇编语法规则，字母开头的数字书写时前面必须补个0
add bx,1000H	;先将低位相加，(bx)=0000, CF=1
adc ax,0020H	;高位相加+CF (ax)=(ax)+0020H+1=3F,最终结果是3F0000
```

例2：编程计算两个128位数据进行相加。

一个128位数据，可分为8组字单元，对于这么多的字单元，我们可以利用内存单元保存数据，然后利用循环依次读入每个字进行计算。

```asm
;	671E 0F04 54F6 8B7A 0A8E 78E6 A8F5 A452H
; +	0452 58F5 78E6 0A8E 8B7A 54F6 EF04 E71EH
;___________________________________________
;										???

assume cs:code,ds:data

data segment
	dw 0A452H,0A8F5H,78F6H,0A8EH,8B7AH,54F6H,0F04H,671EH
	dw 0E71EH,0EF04H,54F6H,8B7AH,0A8EH,78E6H,58F5H,0452H
	;由低地址单元到高地址单元，依次存放由低到高的各个字
data ends

code segment
	start:
		mov ax,data
		mov ds,ax
		mov si,0	;第一个数从第0开始
		mov di,16	;第二个数从第16字内存单元处开始
		mov cx,8	;循环8次，
		
		call add128	;调用子程序计算
		
		mov ax,4c00h
		int 21h
	add128:
		push ax
		push cx
		push si
		push di		;由于子程序会修改寄存器的内容，需要压栈保存之前寄存器的数据
		sub ax,ax	;寄存器值清零，进位标志CF清零
	s:
		mov ax,[si]	;读入第一个加数一个字的内容到ax寄存器
		adc ax,[di]	;读入第二个加数一个字的内容，并与ax中的内容进行相加，结果写回到ax中
		mov [si],ax	;写回结果，覆盖第一个加数内容
		inc si
		inc si	;不使用add，避免产生进位，影响标志位
		inc di
		inc di	;同样避免产生进位，影响标志位
		loop s
		
		pop di
		pop si
		pop cx
		pop ax	;寄存器出栈
		
		ret
code ends

end start
```

#### 3、sbb指令

sbb 是带借位减法指令，它利用了CF 位上记录的借位值。

指令格式：sbb  操作对象1, 操作对象2

功能：操作对象1=操作对象1-操作对象2-CF

例如：sbb ax,bx实现的功能是(ax)=(ax)-(bx)-CF

在进行大数值计算时应用思路和adc类似。

#### 4、cmp指令

​	cmp指令是比较指令，功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。其他指令通过识别这些被影响的标志寄存器位来得知比较结果。

指令格式：cmp  操作对象1，操作对象2

功能：计算操作对象1-操作对象2，不保存结果，仅对标志寄存器进行设置。

```asm
mov ax,8
mov bx,3
cmp ax,bx	; 8-3=5
;执行后 (ax)=8, ZF=0(结果不为0), PF=1(5的二进制中1的个数为偶数), SF=0(结果不为负)
;CF=0(未发生进位), OF=0(结果不溢出)
```

注意：cmp指令既可以对无符号数进行比较，也可以对有符号数进行比较。当进行有符号数进行比较时，需要关注结果是否溢出，如果发生了溢出则实际的结果正负可能和逻辑上的正负有出入。

我们以`cmp ah,bh为例`，总结SF和OF是如何说明比较结果：

- SF=1, OF=0
  - OF=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负;
  - 因 sf1，实际结果为负，所以逻辑上真正的结果为负，所以(ah)<(bh)。
- SF=1, OF=1
  - OF=1说明有溢出，逻辑上真正结果的正负≠实际结果的正负;
  - SF=1说明实际结果为负，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正；
  - SF=1,OF=1，说明了(ah)>(bh)
- SF=0, OF=1
  - OF=1说明有溢出，逻辑上真正结果的正负≠实际结果的正负;
  - SF=0说明实际结果非负，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负
  - SF=0, OF=1，说明了(ah)＜(bh)
- SF=0, OF=0
  - OF=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负;
  - SF=0，实际结果非负，所以逻辑上真正的结果非负，所以(ah)≥(bh)，

#### 5、根据比较结果进行转移的条件转移指令

除了 jcxz 之外，CPU 还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改P。它们检测的是哪些标志位呢?就是被 cmp 指令影响的那些，表示比较结果的标志位。

| 指令 | 含义         | 检测的相关标志位 |
| ---- | ------------ | ---------------- |
| je   | 等于则转移   | ZF=1             |
| jne  | 不等于则转移 | ZF=0             |
| jb   | 低于则转移   | CF=1             |
| jnb  | 不低于则转移 | CF=0             |
| ja   | 高于则转移   | CF=0且ZF=0       |
| jna  | 不高于则转移 | CF=1或ZF=1       |

j表示jump，后面的字母表示意义如下：

- e：equal
- ne：not equal
- b：below
- nb：not below
- a：above
- na：not above

#### 6、串传送指令

**movsb：**

全称是move string byte，即字节传送指令，作用是将一个地方的内存数据(字节)复制到另外一个地方。执行movsb指令时，实际上是将源地址中的一个字节数据复制到目标地址中。

操作过程：

- ((es)*16+(di)) = ((ds)\*16+(si))
- 如果DF=0，(si)=(si)+1，(di)=(di)+1
- 如果DF=1，(si)=(si)-1，(di)=(di)-1

假设汇编语言支持以下语法，则movsb可以描述为：

```asm
mov es:[di], byte ptr ds:[si]
;如果df=0
inc si
inc di

;如果df=1
dec si
dec di
```

**movsw:**

类似于movsb，区别是传入一个字，根据DF的值决定是递增2还是递减2

假设汇编语言支持以下语法，则movsb可以描述为：

```asm
mov es:[di], word ptr ds:[si]

;如果df=0
add si,2
add di,2

;如果df=1
sub si,2
sub di,2
```

**rep:**

repeat重复传送。movsb和movsw进行的是串传送操作中的一个步骤，一般和rep指令配合使用。

指令格式：rep movsb、rep movsw

相当于：

```asm
s:movsb
  loop s
```

rep会根据cx寄存器中的值，重复执行后面的串传送指令，这样一来就实现了循环传送字符。

#### 7、pushf和popf

- pushf 的功能是将标志寄存器的值压栈，而 popf 是从栈中弹出数据，送入标志寄存
  器中。
- pushf和 popf，为直接访问标志寄存器提供了一种方法。

## 八、中断

**中断机制：**

​	CPU在执行完一条指令后，检测到从CPU外部发送过来或者内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。CPU处理中断时必须暂停当前执行的程序，转而执行另一段程序（即中断服务程序），处理完毕后，CPU再返回到原来被暂停的程序，继续从断点处执行下去。

**中断信息：**

​	这里所说的中断信息是逻辑上的说法，它是对几个具有先后顺序的硬件操作所产生的事件的统一描述。

#### 1、内中断的产生

对于8086CPU，当CPU内部有以下情况发生时，将产生相应的中断信息：

- 除法错误：div指令产生的除法溢出（中断类型码0）；
- 单步执行（中断类型码1）；
- 执行into指令（中断类型码4）；
- 执行int指令（int n,n为立即数）

​	CPU根据中断信息提供的类型码来识别中断信息的来源，中断类型码为一个字节型的数据，可以表示256种中断信息的来源。

#### 2、中断处理程序

用于处理中断信息的程序被称为中断程序。

对于中断程序，我们需要知道：

- 中断程序存放在哪里
- 如何找到中断程序入口并调用中断程序

由于CPU随时都可能检测到中断信息，执行中断程序，所以中断处理程序必须一直存储在内存某段空间之中。而中断程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。

中断程序的编写步骤：

- 保存用到的寄存器；
- 处理中断；
- 恢复用到的寄存器；
- 用iret指令返回

iret指令的功能用汇编语法描述为：

```asm
pop IP
pop CS
popf
```

iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。

#### 3、中断向量表

- 中断向量表，就是中断处理程序入口地址的列表。
- 中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。
- CPU只要知道了中断类型码，就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到中断处理程序的入口地址。

​	对于8086CPU来说，中断向量表保存在内存地址0处，从0000：0000~0000：03FF的1024个单元中存放着中断向量表。

​	一个表项占两个字，高地址存放段地址，低地址字存放偏移地址。

![](F:\.计算机知识学习资料\Assembly\learn-assembly-8086\img\27-中断向量表.png)

#### 4、中断过程

​	用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。CPU硬件完成这个工作的过程被称为中断过程。

8086CPU在收到中断信息后，引发的中断过程如下：

- 从中断信息中取得中断类型码；
- 标志寄存器的值入栈（中断过程中会改变标志寄存器的值，所以先保存在栈中）;
- 设置标志寄存器的第8位TF、第9位IF的值为0；
- CS寄存器中的内容入栈；
- IP寄存器中的内容入栈；
- 设置CS和IP（中断程序入口地址），CS=内存地址为中断类型码*4，IP=内存地址为中断类型码\*4+2，两个字单元。

更简洁的描述中断过程：

- 取得中断类型码N
- pushf
- TF=0，IF=0
- push CS
- push IP
- (IP)=(N*4), (CS)=(N\*4+2)

在最后一步完成后，CPU 开始执行由程序员编写的中断处理程序。

#### 5、由int指令引发的中断

指令格式：int n，n为一个立即数，即中断类型码

CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下：

- 取中断类型码n；
- 标志寄存器入栈，IF=0，TF=0；
- CS、IP入栈；
- (IP)=(n*4)，(CS)=(n\*4+2)；
- 从CS:IP处转去执行n号中断的中断处理程序。

#### 6、外中断

​	另一种中断信息来自于CPU外部，比如外设输入（键盘输入）到达，相关芯片将向CPU发出相应的中断信息，CPU在执行完当前指令后，检测到发送过来的中断信息，引发中断过程，处理外设的输入。

**可屏蔽中断：**

CPU可以不响应的中断，标志寄存器中的IF位影响是否相应中断：

- IF=0，不响应中断
- IF=1，CPU执行完当前指令后相应中断

8086CPU提供了设置IF位的指令：

```asm
sti		;set IF=1
cli		;set IF=0
```

​	现在，我们可以解释中断过程中将 正 置为0的原因了。将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。

**不可屏蔽中断：**

CPU必须响应的外中断，当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。

对于 8086CPU，不可屏蔽中断的中断类型码固定为 2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为:

- 标志寄存器入栈，IF=0，TF=0
- CS、IP入栈
- (IP)=8，(CS)=(0AH)

## 九、端口

​	CPU可以通过总线和各种设备通信。这些设备中，都包含独立的处理芯片，除了各种存储器外，还有以下3种芯片：

- 各种接口卡上的芯片，例如网卡、显卡等，他们控制接口卡进行工作
- 板载芯片，即主板上提供的芯片，CPU通过它们对部分外设进行访问
- 其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理

​	在这些芯片中，都有一组可以由 CPU 读写的寄存器。这些寄存器，它们在物理上可能处于不同的芯片中，但是它们在以下两点上相同。

- 都和 CPU 的总线相连，当然这种连接是通过它们所在的芯片进行的
- CPU 对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令

​	可见，从 CPU 的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。

CPU 可以直接读写以下3个地方的数据

- CPU 内部的寄存器
- 内存单元
- 端口

#### 1、端口的读写

- 访问端口时，CPU通过端口地址来定位端口，端口地址和内存地址一样，通过数据总线传输。
- PC系统中，CPU最多可以定位64KB个不同的端口，地址范围为0~65535。
- 对于端口的读写指令只有两条，in（读取）和out（写入）。

**访问端口过程：**

```asm
int al,60h		;从60h号端口读入一个字节
```

- CPU通过地址线将地址信息60h发出；
- CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；
- 端口所在的芯片将60h端口中的数据通过数据总线送入CPU。

注意：in和out指令，只能使用ax或al来存放从端口中读入的数据或发送到端口中的数据；访问8位端口时用al，访问16位端口时用ax。

对0~255以内的端口进行读写时：

```asm
in al,20h		;从20h端口读入一个字节
out 20h,al		;往20h端口写入一个字节
```

对256~65536的端口进行读写时，端口号放在dx中：

```asm
mov dx,3f8h		;将端口号3f8h
in al,dx		;从3f8h端口读入一个字节
out dx,al		;向3f8h端口写入一个字节
```

#### 2、CMOS RAM芯片

PC 机中，有一个 CMOS RAM 芯片，一般简称为 CMOS。此芯片的特征如下：

- 包含一个实时钟和一个有128个存储单元的RAM存储器。
- 该芯片靠电池供电，关机后其内部实时钟仍可正常工作，RAM中的信息不丢失。
- 128个字节的RAM中，内部实时时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。
- 该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS RAM。
- 70h为地址端口，存放的是要访问的CMOS RAM单元的地址。
- 71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。

例子：

编程读取CMOS RAM的2号单元的内容

```asm
assume cs:code

code segment
	start:
		mov al,2	;给出要访问CMOS RAM单元的地址
		out 70H,al	;往70H端口写入要访问的RAM单元地址
		in al,71H	;从71H端口读出2号单元的内容(一个字节)
		
		mov ax,4c00H
		int 21H
code ends

end start
```

编程向CMOS RAM的2号单元写入0

```asm
mov al,2
out 70h,al
mov al,0
out 71h,al
```

